============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\.env
============================================


DATABASE_URL="mysql://root:root@localhost:3306/habana_express_store"
PORT=4000

JWT_SECRET="Gabry123"

============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\habana_express_store.sql
============================================
/*
Navicat MySQL Data Transfer

Source Server         : MySQL
Source Server Version : 50724
Source Host           : 127.0.0.1:3306
Source Database       : habana_express_store

Target Server Type    : MYSQL
Target Server Version : 50724
File Encoding         : 65001

Date: 2026-01-15 16:09:02
*/

SET FOREIGN_KEY_CHECKS=0;


-- --------------------------------------------------------
-- ðŸ“¦ HABANA EXPRESS STORE - ESTRUCTURA FINAL 2026
-- --------------------------------------------------------

-- 1. Crear Base de Datos con soporte para Emojis
DROP DATABASE IF EXISTS habana_express_store;
CREATE DATABASE habana_express_store
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_unicode_ci;

USE habana_express_store;


-- ----------------------------
-- Table structure for categories
-- ----------------------------
DROP TABLE IF EXISTS `categories`;
CREATE TABLE `categories` (
  `id_category` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `active` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id_category`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for products
-- ----------------------------
DROP TABLE IF EXISTS `products`;
CREATE TABLE `products` (
  `id_product` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `purchase_price` decimal(10,2) NOT NULL,
  `sale_price` decimal(10,2) NOT NULL,
  `stock` int(11) NOT NULL DEFAULT '0',
  `sku` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `supplier_name` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `date_added` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `active` tinyint(1) NOT NULL DEFAULT '1',
  `photo_url` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `warranty` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id_product`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for product_categories
-- ----------------------------
DROP TABLE IF EXISTS `product_categories`;
CREATE TABLE `product_categories` (
  `id_product_category` int(11) NOT NULL AUTO_INCREMENT,
  `id_product` int(11) NOT NULL,
  `id_category` int(11) NOT NULL,
  PRIMARY KEY (`id_product_category`),
  KEY `product_categories_id_category_fkey` (`id_category`),
  KEY `product_categories_id_product_fkey` (`id_product`),
  CONSTRAINT `product_categories_id_category_fkey` FOREIGN KEY (`id_category`) REFERENCES `categories` (`id_category`) ON UPDATE CASCADE,
  CONSTRAINT `product_categories_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products` (`id_product`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for returns
-- ----------------------------
DROP TABLE IF EXISTS `returns`;
CREATE TABLE `returns` (
  `id_return` int(11) NOT NULL AUTO_INCREMENT,
  `id_sale` int(11) NOT NULL,
  `id_product` int(11) NOT NULL,
  `quantity` int(11) NOT NULL,
  `return_date` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `loss_usd` decimal(12,2) NOT NULL,
  `reason` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id_return`),
  KEY `returns_id_product_fkey` (`id_product`),
  KEY `returns_id_sale_fkey` (`id_sale`),
  CONSTRAINT `returns_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products` (`id_product`) ON UPDATE CASCADE,
  CONSTRAINT `returns_id_sale_fkey` FOREIGN KEY (`id_sale`) REFERENCES `sales` (`id_sale`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for sales
-- ----------------------------
DROP TABLE IF EXISTS `sales`;
CREATE TABLE `sales` (
  `id_sale` int(11) NOT NULL AUTO_INCREMENT,
  `sale_date` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `exchange_rate` decimal(10,4) NOT NULL,
  `total_cup` decimal(12,2) NOT NULL,
  `buyer_phone` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `notes` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `payment_method` enum('cash','transfer') COLLATE utf8mb4_unicode_ci NOT NULL,
  `id_seller` int(11) NOT NULL,
  PRIMARY KEY (`id_sale`),
  KEY `sales_id_seller_fkey` (`id_seller`),
  CONSTRAINT `sales_id_seller_fkey` FOREIGN KEY (`id_seller`) REFERENCES `users` (`id_user`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for sale_products
-- ----------------------------
DROP TABLE IF EXISTS `sale_products`;
CREATE TABLE `sale_products` (
  `id_sale_product` int(11) NOT NULL AUTO_INCREMENT,
  `id_sale` int(11) NOT NULL,
  `id_product` int(11) NOT NULL,
  `quantity` int(11) NOT NULL,
  PRIMARY KEY (`id_sale_product`),
  KEY `sale_products_id_product_fkey` (`id_product`),
  KEY `sale_products_id_sale_fkey` (`id_sale`),
  CONSTRAINT `sale_products_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products` (`id_product`) ON UPDATE CASCADE,
  CONSTRAINT `sale_products_id_sale_fkey` FOREIGN KEY (`id_sale`) REFERENCES `sales` (`id_sale`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for seller_products
-- ----------------------------
DROP TABLE IF EXISTS `seller_products`;
CREATE TABLE `seller_products` (
  `id_seller_product` int(11) NOT NULL AUTO_INCREMENT,
  `id_seller` int(11) NOT NULL,
  `id_product` int(11) NOT NULL,
  `quantity` int(11) NOT NULL DEFAULT '0',
  `assigned_at` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  PRIMARY KEY (`id_seller_product`),
  KEY `seller_products_id_product_fkey` (`id_product`),
  KEY `seller_products_id_seller_fkey` (`id_seller`),
  CONSTRAINT `seller_products_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products` (`id_product`) ON UPDATE CASCADE,
  CONSTRAINT `seller_products_id_seller_fkey` FOREIGN KEY (`id_seller`) REFERENCES `users` (`id_user`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for shipments
-- ----------------------------
DROP TABLE IF EXISTS `shipments`;
CREATE TABLE `shipments` (
  `id_shipment` int(11) NOT NULL AUTO_INCREMENT,
  `agency_name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `shipment_date` date NOT NULL,
  `shipping_cost_usd` decimal(12,2) NOT NULL,
  `merchandise_cost_usd` decimal(12,2) NOT NULL,
  `customs_fee_cup` decimal(12,2) NOT NULL,
  `exchange_rate` decimal(10,4) NOT NULL,
  `notes` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id_shipment`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for system_configuration
-- ----------------------------
DROP TABLE IF EXISTS `system_configuration`;
CREATE TABLE `system_configuration` (
  `id_config` int(11) NOT NULL AUTO_INCREMENT,
  `company_name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `company_phone` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `company_email` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `logo_url` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `description` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `seller_commission_percentage` decimal(5,2) NOT NULL,
  `monthly_report_day` int(11) DEFAULT NULL,
  `monthly_report_time` time DEFAULT NULL,
  `annual_report_day` int(11) DEFAULT NULL,
  `annual_report_time` time DEFAULT NULL,
  `default_exchange_rate` decimal(10,4) NOT NULL,
  `telegram_bot_token` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `active` tinyint(1) NOT NULL DEFAULT '1',
  `exchange_rate_sync_time` time DEFAULT NULL,
  PRIMARY KEY (`id_config`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `id_user` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `phone` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `photo_url` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `password_hash` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `telegram_chat_id` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `role` enum('admin','seller','storekeeper') COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `active` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id_user`),
  UNIQUE KEY `phone` (`phone`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\package.json
============================================
{
  "name": "habana-express-api",
  "version": "1.0.0",
  "description": "Habana Express Store API",
  "main": "src/index.js",
  "type": "module",
  "scripts": {
    "dev": "nodemon src/index.js",
    "start": "node src/index.js",
    "prisma:generate": "prisma generate",
    "prisma:push": "prisma db push",
    "prisma:studio": "prisma studio"
  },
  "dependencies": {
    "@prisma/client": "^5.10.0",
    "apollo-server-express": "^3.13.0",
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.1",
    "express": "^4.18.2",
    "graphql": "^16.8.1",
    "jsonwebtoken": "^9.0.3",
    "multer": "^2.0.2",
    "node-cron": "^4.2.1",
    "telegraf": "^4.16.3"
  },
  "devDependencies": {
    "nodemon": "^3.0.3",
    "prisma": "^5.10.0"
  }
}


============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma.config.ts
============================================
// This file was generated by Prisma, and assumes you have installed the following:
// npm install --save-dev prisma dotenv
import "dotenv/config";
import { defineConfig } from "prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    url: process.env["DATABASE_URL"],
  },
});


============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\README.md
============================================
<div align="center">

  <h1>?? Habana Express API</h1>
  <h3>Backend Oficial para Habana Express Store</h3>

  <p>
    <img src="https://img.shields.io/badge/Node.js-18.x-339933?style=for-the-badge&logo=node.js&logoColor=white" alt="NodeJS" />
    <img src="https://img.shields.io/badge/GraphQL-Apollo-E10098?style=for-the-badge&logo=graphql&logoColor=white" alt="GraphQL" />
    <img src="https://img.shields.io/badge/Prisma-ORM-2D3748?style=for-the-badge&logo=prisma&logoColor=white" alt="Prisma" />
    <img src="https://img.shields.io/badge/MySQL-DB-4479A1?style=for-the-badge&logo=mysql&logoColor=white" alt="MySQL" />
    <img src="https://img.shields.io/badge/Telegram-Bot-26A5E4?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram" />
  </p>

  <p>
    <b>"Productos internacionales al alcance de tu mano a un buen precio."</b>
    <br>
    <i>Un sistema robusto para log¡stica, inventario descentralizado y finanzas automatizadas en Cuba.</i>
  </p>

</div>

<hr>

## ?? Visi¢n del Proyecto

Nuestro objetivo es ofrecer una plataforma tecnol¢gica que simplifique el comercio electr¢nico, superando las barreras de la doble moneda (USD/CUP). El sistema integra **Gesti¢n de Stock en Tiempo Real**, **C lculo Financiero Avanzado** y **Notificaciones v¡a Telegram**, permitiendo una operaci¢n transparente y eficiente.

---

## ??? Stack Tecnol¢gico

<div align="center">

| Tecnolog¡a | Uso en el Proyecto |
| :--- | :--- |
| **Node.js + Express** | Core del servidor y endpoints REST auxiliares. |
| **GraphQL (Apollo)** | API principal para consultas flexibles y tipadas. |
| **Prisma ORM** | Capa de acceso a datos y gesti¢n de migraciones MySQL. |
| **MySQL** | Base de datos relacional (Esquema `habana_express_store`). |
| **Telegraf + Node-Cron** | Bot de notificaciones y tareas programadas (Reportes). |
| **JWT & Bcrypt** | Seguridad y autenticaci¢n basada en **Tel‚fono**. |

</div>

---

## ?? L¢gica de Negocio y Finanzas

El sistema implementa reglas estrictas para asegurar la rentabilidad y el control.

### 1. Gesti¢n de Inventario Autom tica
*   ?? **Reactiva:** Si entra stock a un producto inactivo, se activa autom ticamente.
*   ?? **Desactiva:** Si el stock llega a `0` tras una venta, el producto se oculta autom ticamente.
*   ?? **Inventario Asignado:** Cada vendedor (Seller) visualiza solo la mercanc¡a que el Almacenero le ha asignado.

### 2. F¢rmula Financiera (Strict Profit Logic)
<details>
<summary><b>?? Haz clic para ver la f¢rmula matem tica de ganancia</b></summary>
<br>

El sistema calcula la ganancia real descontando todos los factores operativos y espirituales:

```math
1. Ganancia Operativa = Ingresos - (Costo Mercanc¡a + Env¡o + Aranceles + P‚rdidas Devoluci¢n + Comisiones Seller)

2. Diezmo = Ganancia Operativa * 10%

3. GANANCIA NETA FINAL = Ganancia Operativa - Diezmo


?? Habana Express Bot
Un asistente virtual integrado en Telegram que notifica en tiempo real seg£n el rol del usuario.
<div align="center">
Rol de Usuario	Evento	Descripci¢n de la Notificaci¢n
?? Admin	
Nueva Venta	Detalle de ingresos, desglose de costos y Ganancia Neta Real.
Reportes	
Estados Financieros autom ticos (Mensual y Anual).
Alertas	Notificaci¢n de devoluciones y p‚rdidas.
?? Seller	Comisi¢n	Notificaci¢n inmediata de la ganancia obtenida ($) por su venta.
?? Storekeeper	Devoluci¢n	Alerta para reingreso de stock al inventario f¡sico.
</div>
Comandos de Administraci¢n
/start - Inicia el bot y obtiene el Chat ID.
/monthly - Genera el Estado Financiero Mensual (Estilo Financial Statement).
/yearly - Genera el Estado Financiero Anual con c lculo de ROI.
/help - Men£ de ayuda.

?? Instalaci¢n y Puesta en Marcha
Sigue estos pasos para levantar el servidor backend.
1. Clonar y Preparar

git clone https://github.com/dreamer95g/habana-express-api.git
cd habana-express-api
npm install

2. Variables de Entorno (.env)
DATABASE_URL="mysql://root:root@localhost:3306/habana_express_store"
PORT=4000
JWT_SECRET="TU_SECRETO_2026"

3. Base de Datos (Seed)
# Crear tablas y poblar con datos de prueba
npx prisma db push
node prisma/seed.js

Seed Info: Crea Admin (50000001), Seller (50000002) y Storekeeper (50000003) con pass 123456.

4. Ejecutar
npm run dev

?? Uso de la API
Accede al Playground en: http://localhost:4000/graphql
Ejemplo: Obtener Reporte Anual

query {
  annualReport {
    year
    totalNetProfit
    breakdown {
      month
      investment
      profit
      roiPercentage
    }
  }
}

?? Estructura del Proyecto
src/
ÃÄÄ services/       # ?? L¢gica Financiera (C lculos matem ticos)
³   ÀÄÄ finance.js
ÃÄÄ auth.js         # Seguridad (JWT & Hash)
ÃÄÄ index.js        # Entry point (Express + Apollo)
ÃÄÄ resolvers.js    # Controladores GraphQL
ÃÄÄ schema.js       # Definiciones de Tipos (TypeDefs)
ÀÄÄ telegram.js     # ?? L¢gica del Bot (Comandos y Notificaciones)
prisma/
ÃÄÄ schema.prisma   # Modelado de Base de Datos
ÀÄÄ seed.js         # Datos de prueba

<br>
<div align="center">
<hr>
<p>Desarrollado con ?? para <b>Habana Express Store</b></p>
<p><b>Gabry95g</b> &bull; 2026 &bull; Licencia ISC</p>
</div>

============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma\schema.prisma
============================================
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model system_configuration {
  id_config                    Int       @id @default(autoincrement())
  company_name                 String
  company_phone                String?
  company_email                String?
  logo_url                     String?
  description                  String?
  seller_commission_percentage Decimal   @db.Decimal(5, 2)
  
  // âœ¨ NUEVO CAMPO: Hora de sincronizaciÃ³n de tasa (Ej: 08:00:00)
  exchange_rate_sync_time      DateTime? @db.Time(0)

  monthly_report_day           Int?
  monthly_report_time          DateTime? @db.Time(0)
  annual_report_day            Int?
  annual_report_time           DateTime? @db.Time(0)
  
  default_exchange_rate        Decimal   @db.Decimal(10, 4)
  telegram_bot_token           String
  created_at                   DateTime  @default(now())
  active                       Boolean   @default(true)
}

model users {
  id_user          Int               @id @default(autoincrement())
  name             String
  phone            String            @unique
  email            String?
  photo_url        String?
  password_hash    String
  telegram_chat_id String?
  role             Role
  created_at       DateTime          @default(now())
  active           Boolean           @default(true)
  sales            sales[]
  seller_products  seller_products[]
}

model products {
  id_product         Int                  @id @default(autoincrement())
  name               String
  description        String?
  purchase_price     Decimal              @db.Decimal(10, 2)
  sale_price         Decimal              @db.Decimal(10, 2)
  stock              Int                  @default(0)
  sku                String?
  supplier_name      String?
  date_added         DateTime             @default(now())
  active             Boolean              @default(true)
  photo_url          String?
  warranty           Boolean              @default(false)
  product_categories product_categories[]
  returns            returns[]
  sale_products      sale_products[]
  seller_products    seller_products[]
}

model categories {
  id_category        Int                  @id @default(autoincrement())
  name               String
  active             Boolean              @default(true)
  product_categories product_categories[]
}

model product_categories {
  id_product_category Int        @id @default(autoincrement())
  id_product          Int
  id_category         Int
  category            categories @relation(fields: [id_category], references: [id_category])
  product             products   @relation(fields: [id_product], references: [id_product])

  @@index([id_category], map: "product_categories_id_category_fkey")
  @@index([id_product], map: "product_categories_id_product_fkey")
}

model sales {
  id_sale        Int             @id @default(autoincrement())
  sale_date      DateTime        @default(now())
  exchange_rate  Decimal         @db.Decimal(10, 4)
  total_cup      Decimal         @db.Decimal(12, 2)
  buyer_phone    String
  notes          String?
  payment_method PaymentMethod
  id_seller      Int
  returns        returns[]
  sale_products  sale_products[]
  seller         users           @relation(fields: [id_seller], references: [id_user])

  @@index([id_seller], map: "sales_id_seller_fkey")
}

model sale_products {
  id_sale_product Int      @id @default(autoincrement())
  id_sale         Int
  id_product      Int
  quantity        Int
  product         products @relation(fields: [id_product], references: [id_product])
  sale            sales    @relation(fields: [id_sale], references: [id_sale])

  @@index([id_product], map: "sale_products_id_product_fkey")
  @@index([id_sale], map: "sale_products_id_sale_fkey")
}

model returns {
  id_return   Int      @id @default(autoincrement())
  id_sale     Int
  id_product  Int
  quantity    Int
  return_date DateTime @default(now())
  loss_usd    Decimal  @db.Decimal(12, 2)
  reason      String?
  product     products @relation(fields: [id_product], references: [id_product])
  sale        sales    @relation(fields: [id_sale], references: [id_sale])

  @@index([id_product], map: "returns_id_product_fkey")
  @@index([id_sale], map: "returns_id_sale_fkey")
}

model shipments {
  id_shipment          Int      @id @default(autoincrement())
  agency_name          String
  shipment_date        DateTime @db.Date
  shipping_cost_usd    Decimal  @db.Decimal(12, 2)
  merchandise_cost_usd Decimal  @db.Decimal(12, 2)
  customs_fee_cup      Decimal  @db.Decimal(12, 2)
  exchange_rate        Decimal  @db.Decimal(10, 4)
  notes                String?
}

model seller_products {
  id_seller_product Int      @id @default(autoincrement())
  id_seller         Int
  id_product        Int
  quantity          Int      @default(0)
  assigned_at       DateTime @default(now())
  product           products @relation(fields: [id_product], references: [id_product])
  seller            users    @relation(fields: [id_seller], references: [id_user])

  @@index([id_product], map: "seller_products_id_product_fkey")
  @@index([id_seller], map: "seller_products_id_seller_fkey")
}

enum Role {
  admin
  seller
  storekeeper
}

enum PaymentMethod {
  cash
  transfer
}.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma\seed.js
============================================
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs'; // AsegÃºrate de tenerlo instalado: npm install bcryptjs

const prisma = new PrismaClient();

async function main() {
  console.log('ðŸŒ± Iniciando Seed (Semilla de Datos)...');

  // 1. LIMPIEZA: Borrar datos antiguos (Orden especÃ­fico por llaves forÃ¡neas)
  await prisma.returns.deleteMany();
  await prisma.sale_products.deleteMany();
  await prisma.sales.deleteMany();
  await prisma.seller_products.deleteMany();
  await prisma.product_categories.deleteMany();
  await prisma.products.deleteMany();
  await prisma.categories.deleteMany();
  await prisma.shipments.deleteMany();
  await prisma.users.deleteMany();
  await prisma.system_configuration.deleteMany();

  console.log('ðŸ§¹ Base de datos limpiada.');

  // 2. HASHEAR PASSWORD (Usaremos '123456' para todos)
  const passwordHash = await bcrypt.hash('123456', 10);

  // 3. CONFIGURACIÃ“N DEL SISTEMA
  // Fecha para reporte: 8:00 AM
  const reportTime = new Date();
  reportTime.setHours(8, 0, 0, 0);

  await prisma.system_configuration.create({
    data: {
      company_name: "Habana Express Store",
      company_phone: "+53 50000000",
      company_email: "contacto@habanaexpress.com",
      description: "Tienda de importaciÃ³n y retail.",
      seller_commission_percentage: 10.00, // 10%
      default_exchange_rate: 520.00,       // Tasa 520
      telegram_bot_token: "8584827308:AAFL5AN7Made0xCe2uz2_0GwWRhBNvIaaqI", // Tu Token Real
      
      // ConfiguraciÃ³n de Reportes
      monthly_report_day: 20,
      monthly_report_time: reportTime,
      annual_report_day: 20, // Diciembre se valida por cÃ³digo, aquÃ­ guardamos el dÃ­a
      annual_report_time: reportTime,
    }
  });
  console.log('âš™ï¸ ConfiguraciÃ³n creada.');

  // 4. USUARIOS
  const admin = await prisma.users.create({
    data: {
      name: "Super Admin",
      phone: "50000001", // Login Admin
      email: "admin@test.com",
      password_hash: passwordHash,
      role: "admin",
      telegram_chat_id: "888319060", // TU CHAT ID REAL
      active: true
    }
  });

  const seller = await prisma.users.create({
    data: {
      name: "Vendedor Estrella",
      phone: "50000002", // Login Seller
      email: "seller@test.com",
      password_hash: passwordHash,
      role: "seller",
      telegram_chat_id: "123456789", // Fake ID
      active: true
    }
  });

  const storekeeper = await prisma.users.create({
    data: {
      name: "Jefe de AlmacÃ©n",
      phone: "50000003", // Login Storekeeper
      email: "store@test.com",
      password_hash: passwordHash,
      role: "storekeeper",
      telegram_chat_id: "987654321", // Fake ID
      active: true
    }
  });
  console.log('ðŸ‘¥ Usuarios creados (Admin, Seller, Storekeeper).');

  // 5. CATEGORÃAS
  const catElec = await prisma.categories.create({ data: { name: "ElectrÃ³nica" } });
  const catHome = await prisma.categories.create({ data: { name: "Hogar" } });

  // 6. ENVÃO (INVERSIÃ“N INICIAL)
  // Simulamos que trajimos mercancÃ­a para vender
  await prisma.shipments.create({
    data: {
      agency_name: "Aerovaradero",
      shipment_date: new Date(), // Fecha de hoy
      shipping_cost_usd: 150.00,
      merchandise_cost_usd: 1200.00, // Costo de los productos abajo
      customs_fee_cup: 5000.00,      // Aranceles
      exchange_rate: 520.00,
      notes: "EnvÃ­o inicial de prueba"
    }
  });
  console.log('âœˆï¸ EnvÃ­o de inversiÃ³n creado.');

  // 7. PRODUCTOS
  // Prod 1: iPhone 13 (Costo $400)
  const product1 = await prisma.products.create({
    data: {
      name: "iPhone 13 Refurbished",
      description: "128GB, BaterÃ­a 100%",
      purchase_price: 400.00, 
      sale_price: 900.00,    // Venta en USD (referencial)
      stock: 5,              // Stock inicial
      sku: "IPH13-128",
      active: true,
      warranty: true,
      product_categories: { create: { id_category: catElec.id_category } }
    }
  });

  // Prod 2: AirFryer (Costo $50)
  const product2 = await prisma.products.create({
    data: {
      name: "AirFryer Xiaomi 4L",
      description: "Freidora de aire inteligente",
      purchase_price: 50.00,
      sale_price: 120.00,
      stock: 10,
      sku: "AF-XIAOMI",
      active: true,
      warranty: false,
      product_categories: { create: { id_category: catHome.id_category } }
    }
  });

  // 8. ASIGNAR PRODUCTO AL VENDEDOR
  await prisma.seller_products.create({
    data: {
      id_seller: seller.id_user,
      id_product: product1.id_product,
      quantity: 2 // Le damos 2 iPhones para vender
    }
  });

  // 9. VENTA (SimulaciÃ³n)
  // El vendedor vende 1 iPhone.
  // CÃ¡lculo: $900 USD * 520 Tasa = 468,000 CUP
  const sale = await prisma.sales.create({
    data: {
      id_seller: seller.id_user,
      sale_date: new Date(),
      exchange_rate: 520.00,
      total_cup: 468000.00, // $900 USD
      buyer_phone: "5355555555",
      payment_method: "cash",
      notes: "Venta de prueba seed",
      sale_products: {
        create: {
          id_product: product1.id_product,
          quantity: 1
        }
      }
    }
  });

  // Actualizar stock tras venta (manual en seed)
  await prisma.products.update({
    where: { id_product: product1.id_product },
    data: { stock: 4 } // Eran 5, vendiÃ³ 1
  });
  console.log('ðŸ’° Venta registrada.');

  // 10. DEVOLUCIÃ“N (SimulaciÃ³n)
  // Alguien devuelve una AirFryer de una venta anterior hipotÃ©tica
  // Primero creamos la venta de la AirFryer
  const saleReturn = await prisma.sales.create({
    data: {
      id_seller: seller.id_user,
      sale_date: new Date(),
      exchange_rate: 520.00,
      total_cup: 62400.00, // $120 * 520
      buyer_phone: "5359999999",
      payment_method: "transfer",
      sale_products: { create: { id_product: product2.id_product, quantity: 1 } }
    }
  });

  // Ahora registramos la devoluciÃ³n
  await prisma.returns.create({
    data: {
      id_sale: saleReturn.id_sale,
      id_product: product2.id_product,
      quantity: 1,
      loss_usd: 10.00, // Se perdiÃ³ $10 en transporte/mensajerÃ­a
      reason: "Producto con golpe de fÃ¡brica", // Usando el nuevo campo
      return_date: new Date()
    }
  });
  console.log('ðŸ”„ DevoluciÃ³n registrada.');

  console.log('âœ… SEED COMPLETADO EXITOSAMENTE.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma\migrations\migration_lock.toml
============================================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "mysql"
.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma\migrations\20260109141221_init\migration.sql
============================================
-- CreateTable
CREATE TABLE `system_configuration` (
    `id_config` INTEGER NOT NULL AUTO_INCREMENT,
    `company_name` VARCHAR(191) NOT NULL,
    `logo_url` VARCHAR(191) NULL,
    `description` VARCHAR(191) NULL,
    `seller_commission_percentage` DOUBLE NOT NULL,
    `weekly_report_day` INTEGER NULL,
    `weekly_report_time` DATETIME(3) NULL,
    `monthly_report_day` INTEGER NULL,
    `monthly_report_time` DATETIME(3) NULL,
    `annual_report_day` INTEGER NULL,
    `annual_report_time` DATETIME(3) NULL,
    `default_exchange_rate` DOUBLE NOT NULL,
    `telegram_bot_token` VARCHAR(191) NOT NULL,
    `created_at` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `active` BOOLEAN NOT NULL DEFAULT true,

    PRIMARY KEY (`id_config`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `users` (
    `id_user` INTEGER NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(191) NOT NULL,
    `email` VARCHAR(191) NULL,
    `photo_url` VARCHAR(191) NULL,
    `password_hash` VARCHAR(191) NOT NULL,
    `telegram_chat_id` VARCHAR(191) NULL,
    `role` ENUM('admin', 'seller', 'storekeeper') NOT NULL,
    `created_at` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `active` BOOLEAN NOT NULL DEFAULT true,

    UNIQUE INDEX `users_email_key`(`email`),
    PRIMARY KEY (`id_user`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `products` (
    `id_product` INTEGER NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(191) NOT NULL,
    `description` VARCHAR(191) NULL,
    `purchase_price` DOUBLE NOT NULL,
    `sale_price` DOUBLE NOT NULL,
    `stock` INTEGER NOT NULL DEFAULT 0,
    `sku` VARCHAR(191) NULL,
    `supplier_name` VARCHAR(191) NULL,
    `date_added` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `active` BOOLEAN NOT NULL DEFAULT true,
    `photo_url` VARCHAR(191) NULL,
    `warranty` BOOLEAN NOT NULL DEFAULT false,

    PRIMARY KEY (`id_product`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `categories` (
    `id_category` INTEGER NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(191) NOT NULL,
    `active` BOOLEAN NOT NULL DEFAULT true,

    PRIMARY KEY (`id_category`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `product_categories` (
    `id_product_category` INTEGER NOT NULL AUTO_INCREMENT,
    `id_product` INTEGER NOT NULL,
    `id_category` INTEGER NOT NULL,

    PRIMARY KEY (`id_product_category`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `sales` (
    `id_sale` INTEGER NOT NULL AUTO_INCREMENT,
    `sale_date` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `exchange_rate` DOUBLE NOT NULL,
    `total_cup` DOUBLE NOT NULL,
    `buyer_phone` VARCHAR(191) NOT NULL,
    `notes` VARCHAR(191) NULL,
    `payment_method` ENUM('cash', 'transfer') NOT NULL,
    `id_seller` INTEGER NOT NULL,

    PRIMARY KEY (`id_sale`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `sale_products` (
    `id_sale_product` INTEGER NOT NULL AUTO_INCREMENT,
    `id_sale` INTEGER NOT NULL,
    `id_product` INTEGER NOT NULL,
    `quantity` INTEGER NOT NULL,

    PRIMARY KEY (`id_sale_product`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `returns` (
    `id_return` INTEGER NOT NULL AUTO_INCREMENT,
    `id_sale` INTEGER NOT NULL,
    `id_product` INTEGER NOT NULL,
    `quantity` INTEGER NOT NULL,
    `return_date` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `loss_usd` DOUBLE NOT NULL,
    `notes` VARCHAR(191) NULL,

    PRIMARY KEY (`id_return`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `shipments` (
    `id_shipment` INTEGER NOT NULL AUTO_INCREMENT,
    `agency_name` VARCHAR(191) NOT NULL,
    `shipment_date` DATETIME(3) NOT NULL,
    `shipping_cost_usd` DOUBLE NOT NULL,
    `customs_fee_cup` DOUBLE NOT NULL,
    `exchange_rate` DOUBLE NOT NULL,
    `notes` VARCHAR(191) NULL,

    PRIMARY KEY (`id_shipment`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `seller_products` (
    `id_seller_product` INTEGER NOT NULL AUTO_INCREMENT,
    `id_seller` INTEGER NOT NULL,
    `id_product` INTEGER NOT NULL,
    `quantity` INTEGER NOT NULL DEFAULT 0,
    `assigned_at` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),

    PRIMARY KEY (`id_seller_product`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `product_categories` ADD CONSTRAINT `product_categories_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products`(`id_product`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `product_categories` ADD CONSTRAINT `product_categories_id_category_fkey` FOREIGN KEY (`id_category`) REFERENCES `categories`(`id_category`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `sales` ADD CONSTRAINT `sales_id_seller_fkey` FOREIGN KEY (`id_seller`) REFERENCES `users`(`id_user`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `sale_products` ADD CONSTRAINT `sale_products_id_sale_fkey` FOREIGN KEY (`id_sale`) REFERENCES `sales`(`id_sale`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `sale_products` ADD CONSTRAINT `sale_products_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products`(`id_product`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `returns` ADD CONSTRAINT `returns_id_sale_fkey` FOREIGN KEY (`id_sale`) REFERENCES `sales`(`id_sale`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `returns` ADD CONSTRAINT `returns_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products`(`id_product`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `seller_products` ADD CONSTRAINT `seller_products_id_seller_fkey` FOREIGN KEY (`id_seller`) REFERENCES `users`(`id_user`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `seller_products` ADD CONSTRAINT `seller_products_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products`(`id_product`) ON DELETE RESTRICT ON UPDATE CASCADE;
.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\auth.js
============================================
// src/auth.js
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';

const APP_SECRET = process.env.JWT_SECRET || "fallback_secret_dev";

// 1. Encriptar contraseÃ±a (para cuando creas usuario)
export const hashPassword = (password) => {
  return bcrypt.hash(password, 10);
};

// 2. Comparar contraseÃ±a (para el login)
export const comparePassword = (password, hash) => {
  return bcrypt.compare(password, hash);
};

// 3. Crear Token (darle la llave al usuario)
export const createToken = (user) => {
  return jwt.sign({ userId: user.id_user, role: user.role }, APP_SECRET, {
    expiresIn: '7d', // El token dura 7 dÃ­as
  });
};

// 4. Verificar Token (revisar la llave en cada peticiÃ³n)
export const getUserFromToken = (token) => {
  if (token) {
    try {
      // El token suele venir como "Bearer eyJhbGci..."
      const tokenValue = token.replace('Bearer ', '');
      const verified = jwt.verify(tokenValue, APP_SECRET);
      return verified; // Devuelve { userId: 1, role: 'admin' }
    } catch (error) {
      return null;
    }
  }
  return null;
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\index.js
============================================
import express from "express";
import { ApolloServer } from "apollo-server-express";
import { typeDefs } from "./schema.js";
import { resolvers } from "./resolvers.js";
import { getUserFromToken } from "./auth.js";
import { initTelegramBot } from "./telegram.js"; 
import { initScheduler } from "./services/scheduler.js"; 
import dotenv from 'dotenv';
import multer from 'multer';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const uploadDir = path.join(process.cwd(), 'uploads');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
}

const app = express();

// --- MULTER CONFIG ---
const storage = multer.diskStorage({
  destination: (req, file, cb) => { cb(null, 'uploads/'); },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    cb(null, file.fieldname + '-' + uniqueSuffix + ext);
  }
});

const fileFilter = (req, file, cb) => {
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('â›” Only image files are allowed.'), false);
  }
};

const upload = multer({ storage, fileFilter });

app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

app.post('/api/upload', upload.single('file'), (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: 'No file uploaded.' });
    const protocol = req.protocol;
    const host = req.get('host');
    const fileUrl = `${protocol}://${host}/uploads/${req.file.filename}`;
    res.status(200).json({ message: 'Image uploaded.', url: fileUrl });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// --- SERVER START ---
async function startServer() {
  
  // 1. Init Cron Jobs
  initScheduler();

  // 2. Apollo Server
  const server = new ApolloServer({
    typeDefs,
    resolvers,
    context: ({ req }) => {
      const token = req.headers.authorization || '';
      const user = getUserFromToken(token);
      return { user };
    },
  });

  await server.start();
  server.applyMiddleware({ app });

  // 3. Start Express
  app.listen({ port: process.env.PORT || 4000 }, () => {
    console.log(`ðŸš€ Server ready at http://localhost:4000${server.graphqlPath}`);
    console.log(`ðŸ“‚ Upload endpoint ready at http://localhost:4000/api/upload`);
    
    // 4. Init Telegram (Silent start, success log inside)
    initTelegramBot();
  });
}

startServer();.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\resolvers.js
============================================
import { PrismaClient } from '@prisma/client';
import { hashPassword, comparePassword, createToken } from './auth.js';
import { getMonthlyReport, getAnnualReport, calculateTopSellers } from './services/finance.js';
import { notifySale, notifyReturn, notifyStockDepletion } from './telegram.js';

const prisma = new PrismaClient();

/* ðŸ›¡ï¸ --- SECURITY GUARDS --- ðŸ›¡ï¸ */
const requireAuth = (user) => {
  if (!user) throw new Error('â›” Authorization required.');
};
const requireAdmin = (user) => {
  requireAuth(user);
  if (user.role !== 'admin') throw new Error('â›” Access Denied: Admin role required.');
};
const requireStorekeeper = (user) => {
  requireAuth(user);
  if (user.role !== 'admin' && user.role !== 'storekeeper') throw new Error('â›” Access Denied: Storekeeper required.');
};
const requireSeller = (user) => {
  requireAuth(user);
  if (user.role !== 'admin' && user.role !== 'seller') throw new Error('â›” Access Denied: Seller required.');
};

/* ðŸš€ --- RESOLVERS --- ðŸš€ */

export const resolvers = {
  Query: {
    // Users
    users: (_, __, { user }) => {
      requireAdmin(user);
      return prisma.users.findMany({ include: { seller_products: true, sales: true } });
    },
    user: (_, { id_user }, { user }) => {
      requireAdmin(user);
      return prisma.users.findUnique({ where: { id_user }, include: { seller_products: true, sales: true } });
    },

    // Products
    products: (_, __, { user }) => {
      requireAuth(user);
      return prisma.products.findMany({ 
        where: { active: true }, 
        include: { 
            product_categories: { include: { category: true } }, 
            sale_products: true, 
            seller_products: true 
        } 
      });
    },
    product: (_, { id_product }, { user }) => {
      requireAuth(user);
      return prisma.products.findUnique({ 
          where: { id_product }, 
          include: { 
              product_categories: { include: { category: true } }, 
              seller_products: true 
          } 
      });
    },

    // Categories
    categories: (_, __, { user }) => {
      requireAuth(user);
      return prisma.categories.findMany({ include: { product_categories: true } });
    },

    // Sales & Returns
    sales: (_, __, { user }) => {
      requireStorekeeper(user); 
      return prisma.sales.findMany({ include: { sale_products: { include: { product: true } }, seller: true } });
    },
    sale: (_, { id_sale }, { user }) => {
      requireAuth(user); 
      return prisma.sales.findUnique({ where: { id_sale }, include: { sale_products: { include: { product: true } }, seller: true } });
    },
    returns: (_, __, { user }) => {
      requireStorekeeper(user);
      return prisma.returns.findMany({ include: { product: true, sale: true } });
    },

    // Logistics & Inventory
    shipments: (_, __, { user }) => {
      requireStorekeeper(user);
      return prisma.shipments.findMany();
    },
    sellerProducts: (_, { sellerId }, { user }) => {
      requireAuth(user);
      let targetId = user.role === 'seller' ? user.id_user : sellerId;
      return prisma.seller_products.findMany({
        where: { id_seller: targetId },
        include: { seller: true, product: true },
      });
    },

    // Config & Reports
    systemConfiguration: (_, __, { user }) => {
      requireAuth(user); 
      return prisma.system_configuration.findMany();
    },
    monthlyReport: async (_, __, { user }) => {
      requireAdmin(user);
      return await getMonthlyReport();
    },
    annualReport: async (_, __, { user }) => {
      requireAdmin(user);
      return await getAnnualReport();
    },
    topSellers: async (_, { period }, { user }) => {
      requireAuth(user);
      return await calculateTopSellers(period);
    },
  },

  Mutation: {
    // Auth
    login: async (_, { phone, password }) => {
      const user = await prisma.users.findUnique({ where: { phone } });
      if (!user) throw new Error('User not found');
      
      const valid = await comparePassword(password, user.password_hash);
      if (!valid) throw new Error('Invalid password');
      
      if (!user.active) throw new Error('Account is deactivated');
      
      return { token: createToken(user), user };
    },

    createUser: async (_, { input }, { user }) => {
      requireAdmin(user);
      const hashedPassword = await hashPassword(input.password_hash);
      return prisma.users.create({ data: { ...input, password_hash: hashedPassword } });
    },

    // Config
    updateSystemConfiguration: async (_, { id_config, input }, { user }) => {
      requireAdmin(user);
      return prisma.system_configuration.update({ where: { id_config }, data: input });
    },

    // Products Management
    createCategory: (_, { name }, { user }) => {
       requireStorekeeper(user);
       return prisma.categories.create({ data: { name } });
    },

    createProduct: (_, { input }, { user }) => {
      requireStorekeeper(user);
      
      const { categoryIds, ...productData } = input;
      
      // Auto SKU Generation
      let finalSku = productData.sku;
      if (!finalSku) {
         const year = new Date().getFullYear();
         const randomSuffix = Math.random().toString(36).substring(2, 6).toUpperCase();
         finalSku = `HEX-${year}-${randomSuffix}`;
      }

      const isActive = productData.stock > 0 ? true : (productData.active ?? false);

      return prisma.products.create({ 
          data: { 
              ...productData, 
              sku: finalSku, 
              active: isActive,
              product_categories: {
                create: categoryIds 
                  ? categoryIds.map(id => ({
                      category: { connect: { id_category: id } }
                    })) 
                  : []
              }
          },
          include: { 
            product_categories: { include: { category: true } } 
          }
      });
    },

    updateProduct: async (_, { id_product, input }, { user }) => {
      requireStorekeeper(user);
      
      const { categoryIds, ...dataToUpdate } = input;

      // Reactive Stock Logic
      if (dataToUpdate.stock !== undefined) {
        if (dataToUpdate.stock > 0) {
          dataToUpdate.active = true;
        } else if (dataToUpdate.stock === 0) {
           dataToUpdate.active = false;
        }
      }

      // Update with relation handling
      const prismaUpdateArgs = {
        where: { id_product },
        data: {
            ...dataToUpdate,
            ...(categoryIds && {
                product_categories: {
                    deleteMany: {},
                    create: categoryIds.map(id => ({
                        category: { connect: { id_category: id } }
                    }))
                }
            })
        },
        include: {
            product_categories: { include: { category: true } }
        }
      };

      return prisma.products.update(prismaUpdateArgs);
    },

    deleteProduct: async (_, { id_product }, { user }) => {
      requireStorekeeper(user);
      try {
        return await prisma.products.delete({ where: { id_product } });
      } catch (error) {
        throw new Error("Cannot delete product with dependencies. Try deactivating it.");
      }
    },

    assignProductToSeller: async (_, { sellerId, productId, quantity }, { user }) => {
      requireStorekeeper(user);
      const existing = await prisma.seller_products.findFirst({ where: { id_seller: sellerId, id_product: productId } });
      
      if (existing) {
        return prisma.seller_products.update({
          where: { id_seller_product: existing.id_seller_product },
          data: { quantity: { increment: quantity } },
          include: { seller: true, product: true }
        });
      } else {
        return prisma.seller_products.create({
          data: { id_seller: sellerId, id_product: productId, quantity },
          include: { seller: true, product: true },
        });
      }
    },

    // Sales Logic
    createSale: async (_, { sellerId, exchange_rate, total_cup, buyer_phone, payment_method, notes, items }, { user }) => {
      requireSeller(user);
      if (user.role === 'seller' && user.id_user !== sellerId) throw new Error('Forbidden: Cannot sell for another user.');

      // 1. Stock Validation
      for (const item of items) {
        const product = await prisma.products.findUnique({ where: { id_product: item.productId } });
        if (!product) throw new Error(`Product ID ${item.productId} not found`);
        if (product.stock < item.quantity) {
          throw new Error(`Insufficient stock for: ${product.name}. Available: ${product.stock}`);
        }
      }

      // 2. Create Sale Header
      const sale = await prisma.sales.create({
        data: { id_seller: sellerId, exchange_rate, total_cup, buyer_phone, payment_method, notes },
      });

      // 3. Process Items & Update Inventory
      for (const { productId, quantity } of items) {
        await prisma.sale_products.create({
          data: { id_sale: sale.id_sale, id_product: productId, quantity },
        });

        // Decrement Global Stock
        const updatedProduct = await prisma.products.update({
          where: { id_product: productId },
          data: { stock: { decrement: quantity } },
        });

        // âœ¨ Check for Depletion (Alert Admin)
        if (updatedProduct.stock <= 0) {
          await prisma.products.update({
            where: { id_product: productId },
            data: { active: false }
          });
          // Async notification
          notifyStockDepletion(updatedProduct).catch(e => console.error(e));
        }

        // Decrement Seller's Assigned Stock
        const assigned = await prisma.seller_products.findFirst({
          where: { id_seller: sellerId, id_product: productId },
        });
        if (assigned) {
          await prisma.seller_products.update({
            where: { id_seller_product: assigned.id_seller_product },
            data: { quantity: { decrement: quantity } },
          });
        }
      }

      // 4. Return Data & Notify
      const saleResult = await prisma.sales.findUnique({
        where: { id_sale: sale.id_sale },
        include: { sale_products: { include: { product: true } }, seller: true },
      });

      try {
         await notifySale(saleResult);
      } catch (e) {
        console.error("Telegram Error (Sale):", e.message); 
      }

      return saleResult;
    },

    // Returns Logic
    createReturn: async (_, args, { user }) => {
       requireStorekeeper(user); 
       const { saleId, productId, quantity, loss_usd, reason } = args;
       
       // Record Return
       const ret = await prisma.returns.create({
         data: { id_sale: saleId, id_product: productId, quantity, loss_usd, reason },
         include: { product: true, sale: true }
       });
       
       // Restore Stock
       const prod = await prisma.products.update({
         where: { id_product: productId },
         data: { stock: { increment: quantity } }
       });

       // Reactivate if needed
       if (!prod.active && prod.stock > 0) {
         await prisma.products.update({ where: { id_product: productId }, data: { active: true } });
       }

       // Notify
       try {
         await notifyReturn(ret);
       } catch (e) {
          console.error("Telegram Error (Return):", e.message);
       }

       return ret;
    },

    // Logistics
    createShipment: (_, args, { user }) => { 
      requireAdmin(user); 
      return prisma.shipments.create({ data: args }); 
    },
  },

  // Field Resolvers
  SaleProduct: { 
    product: (parent) => parent.product || prisma.products.findUnique({ where: { id_product: parent.id_product } }) 
  },
  Return: { 
    product: (parent) => parent.product || prisma.products.findUnique({ where: { id_product: parent.id_product } }), 
    sale: (parent) => parent.sale || prisma.sales.findUnique({ where: { id_sale: parent.id_sale } }) 
  },
  SellerProduct: { 
    product: (parent) => parent.product || prisma.products.findUnique({ where: { id_product: parent.id_product } }), 
    seller: (parent) => parent.seller || prisma.users.findUnique({ where: { id_user: parent.id_seller } }) 
  }
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\schema.js
============================================
import { gql } from "apollo-server-express";

export const typeDefs = gql`
  enum Role {
    admin
    seller
    storekeeper
  }

  enum PaymentMethod {
    cash
    transfer
  }

  type SystemConfiguration {
    id_config: Int!
    company_name: String!
    company_phone: String
    company_email: String
    logo_url: String
    description: String
    seller_commission_percentage: Float!
    # âœ‚ï¸ Weekly Eliminado
    monthly_report_day: Int
    monthly_report_time: String
    annual_report_day: Int
    annual_report_time: String
    default_exchange_rate: Float!
    telegram_bot_token: String!
    created_at: String
    active: Boolean
  }

  type User {
    id_user: Int!
    name: String!
    phone: String!
    email: String
    photo_url: String
    telegram_chat_id: String
    role: Role!
    created_at: String
    active: Boolean
    sales: [Sale]
    seller_products: [SellerProduct]
  }

  type AuthPayload {
    token: String!
    user: User!
  }

  type Category {
    id_category: Int!
    name: String!
    active: Boolean
    product_categories: [ProductCategory]
  }

  type Product {
    id_product: Int!
    name: String!
    description: String
    purchase_price: Float!
    sale_price: Float!
    stock: Int
    sku: String
    supplier_name: String
    date_added: String
    active: Boolean
    photo_url: String
    warranty: Boolean
    product_categories: [ProductCategory]
    sale_products: [SaleProduct]
    returns: [Return]
    seller_products: [SellerProduct]
  }

  type ProductCategory {
    id_product_category: Int!
    product: Product!
    category: Category!
  }

  type Sale {
    id_sale: Int!
    sale_date: String
    exchange_rate: Float!
    total_cup: Float!
    buyer_phone: String!
    notes: String
    payment_method: PaymentMethod!
    seller: User!
    sale_products: [SaleProduct]
    returns: [Return]
  }

  type SaleProduct {
    id_sale_product: Int!
    quantity: Int!
    sale: Sale!
    product: Product!
  }

  type Return {
    id_return: Int!
    quantity: Int!
    return_date: String
    loss_usd: Float!
    reason: String # âœ¨ Renombrado
    product: Product!
    sale: Sale!
  }

  type Shipment {
    id_shipment: Int!
    agency_name: String!
    shipment_date: String!
    shipping_cost_usd: Float!
    merchandise_cost_usd: Float! 
    customs_fee_cup: Float!
    exchange_rate: Float!
    notes: String
  }

  type SellerProduct {
    id_seller_product: Int!
    quantity: Int!
    assigned_at: String
    seller: User!
    product: Product!
  }

  type TopSeller {
    id_user: Int!
    name: String!
    photo_url: String
    total_sales_usd: Float! # Total vendido convertido a USD
    items_sold: Int!        # Cantidad de productos vendidos
  }

  # --- REPORT TYPES ---
  
  type MonthlyReport {
    month: Int!
    year: Int!
    income: Float!
    expenses: Float!
    netProfit: Float!
  }

  type AnnualReport {
    year: Int!
    totalNetProfit: Float!
    breakdown: [MonthlyBreakdown]
  }

  type MonthlyBreakdown {
    month: Int!
    investment: Float!      
    profit: Float!          
    roiPercentage: Float!   
  }

  # --- INPUTS ---

  input CreateUserInput {
    name: String!
    phone: String!
    email: String
    photo_url: String
    password_hash: String!
    telegram_chat_id: String
    role: Role!
  }

  input CreateProductInput {
    name: String!
    description: String
    purchase_price: Float!
    sale_price: Float!
    stock: Int
    sku: String
    supplier_name: String
    photo_url: String
    warranty: Boolean
    active: Boolean
    categoryIds: [Int] 
  }

  input UpdateProductInput {
    name: String
    description: String
    purchase_price: Float
    sale_price: Float
    stock: Int
    sku: String
    supplier_name: String
    photo_url: String
    warranty: Boolean
    active: Boolean
    categoryIds: [Int]
  }

  input UpdateSystemConfigurationInput {
    company_name: String
    company_phone: String
    company_email: String
    logo_url: String
    description: String
    seller_commission_percentage: Float
    # âœ‚ï¸ Weekly Eliminado
    monthly_report_day: Int
    monthly_report_time: String
    annual_report_day: Int
    annual_report_time: String
    default_exchange_rate: Float
    telegram_bot_token: String
    active: Boolean
  }

  input SaleItemInput {
    productId: Int!
    quantity: Int!
  }

  # --- QUERY & MUTATION ---

  type Query {
    systemConfiguration: [SystemConfiguration]
    users: [User]
    user(id_user: Int!): User
    products: [Product]
    product(id_product: Int!): Product
    categories: [Category]
    sales: [Sale]
    sale(id_sale: Int!): Sale
    returns: [Return]
    shipments: [Shipment]
    sellerProducts(sellerId: Int!): [SellerProduct]
    monthlyReport: MonthlyReport
    annualReport: AnnualReport
    topSellers(period: String!): [TopSeller]
  }

  type Mutation {
    login(phone: String!, password: String!): AuthPayload
    
    createUser(input: CreateUserInput!): User
    createCategory(name: String!): Category 
    createProduct(input: CreateProductInput!): Product
    updateProduct(id_product: Int!, input: UpdateProductInput!): Product
    deleteProduct(id_product: Int!): Product
    assignProductToSeller(sellerId: Int!, productId: Int!, quantity: Int!): SellerProduct
    
    createSale(
      sellerId: Int!,
      exchange_rate: Float!,
      total_cup: Float!,
      buyer_phone: String!,
      payment_method: PaymentMethod!,
      notes: String,
      items: [SaleItemInput!]!
    ): Sale
    
    # âœ¨ Cambiado notes por reason
    createReturn(saleId: Int!, productId: Int!, quantity: Int!, loss_usd: Float!, reason: String): Return
    
    createShipment(
      agency_name: String!,
      shipment_date: String!,
      shipping_cost_usd: Float!,
      merchandise_cost_usd: Float!,
      customs_fee_cup: Float!,
      exchange_rate: Float!,
      notes: String
    ): Shipment
    
    updateSystemConfiguration(id_config: Int!, input: UpdateSystemConfigurationInput!): SystemConfiguration
  }
`;.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\telegram.js
============================================
import { Telegraf } from 'telegraf';
import { PrismaClient } from '@prisma/client';
import { getMonthlyReport, getAnnualReport } from './services/finance.js';

const prisma = new PrismaClient();
let bot = null;
let isBotRunning = false; 

// --- ðŸ› ï¸ FORMAT HELPERS ---
const formatNumber = (amount) => {
  return new Intl.NumberFormat('en-US', {
    maximumFractionDigits: 0,
    minimumFractionDigits: 0
  }).format(amount);
};

const safeReply = async (chatId, message) => {
    if (!bot) return; 
    try {
        await bot.telegram.sendMessage(chatId, message, { parse_mode: 'HTML' });
    } catch (error) {
        console.error(`âš ï¸ Telegram Send Error (Chat: ${chatId}):`, error.message);
    }
};

// --- ðŸŽ® COMMANDS SETUP ---
const setupCommands = () => {
    const helpMsg = `
ðŸ‘‹ <b>Habana Express Bot</b>

ðŸ“‹ <b>Comandos Disponibles:</b>

ðŸ“Š /monthly - Reporte del Mes
ðŸ“ˆ /yearly - Reporte del AÃ±o
â“ /help - Ayuda
    `;

    bot.start((ctx) => ctx.reply(helpMsg, { parse_mode: 'HTML' }));
    bot.help((ctx) => ctx.reply(helpMsg, { parse_mode: 'HTML' }));

    bot.command('monthly', async (ctx) => {
        try {
            ctx.reply("â³ <i>Generando reporte mensual...</i>", { parse_mode: 'HTML' });
            const data = await getMonthlyReport();
            const roi = data.investment > 0 ? ((data.netProfit / data.investment) * 100).toFixed(1) : 0;
            
            const msg = `
ðŸ“… <b>REPORTE MENSUAL</b> | ${data.month}/${data.year}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ’° <b>Ingresos Totales</b>
<b>(USD)</b> ${formatNumber(data.income)}

ðŸ“‰ <b>InversiÃ³n y Gastos</b>
<b>(USD)</b> ${formatNumber(data.investment + data.returnLosses)}

âœ… <b>GANANCIA NETA</b>
<b>(USD)</b> ${formatNumber(data.netProfit)}

ðŸ“Š <b>ROI:</b> ${roi}%
            `;
            ctx.reply(msg, { parse_mode: 'HTML' });
        } catch (e) {
            console.error("Monthly Report Error:", e);
            ctx.reply("âŒ Error generando reporte.");
        }
    });

    bot.command('yearly', async (ctx) => {
        try {
            ctx.reply("â³ <i>Generando reporte anual...</i>", { parse_mode: 'HTML' });
            const data = await getAnnualReport();
            const roi = data.investment > 0 ? ((data.netProfit / data.investment) * 100).toFixed(1) : 0;

            const msg = `
ðŸ“ˆ <b>REPORTE ANUAL</b> | ${data.year}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ’° <b>Ingresos Acumulados</b>
<b>(USD)</b> ${formatNumber(data.income)}

ðŸ“‰ <b>InversiÃ³n Total</b>
<b>(USD)</b> ${formatNumber(data.investment + data.returnLosses)}

âœ… <b>GANANCIA NETA</b>
<b>(USD)</b> ${formatNumber(data.netProfit)}

ðŸ“Š <b>ROI Anual:</b> ${roi}%
            `;
            ctx.reply(msg, { parse_mode: 'HTML' });
        } catch (e) {
            console.error("Yearly Report Error:", e);
            ctx.reply("âŒ Error generando reporte.");
        }
    });
};





// --- ðŸš€ INITIALIZATION ---
// export const initTelegramBot = async () => {
//   try {
//       const config = await prisma.system_configuration.findFirst();
//       if (!config || !config.telegram_bot_token) {
//         console.warn("âš ï¸ Telegram Bot Token not configured.");
//         return;
//       }

//       bot = new Telegraf(config.telegram_bot_token);
      
      
//       // Global Error Handler
//       bot.catch((err) => console.error(`âŒ Telegram Runtime Error:`, err));
      
//       setupCommands();
      
//       // Active Flag ON immediately
//       isBotRunning = true; 

//       // Silent Launch in Background
//      await bot.launch("hola")
//     //   console.log("ðŸ¤– âœ… Bot connected to Telegram");
//         .then(async () => {
//             console.log("ðŸ¤– âœ… Bot connected to Telegram");
            
//             // âœ¨ NOTIFY ADMINS ON STARTUP
//             const startMsg = `
// ðŸŸ¢ <b>SISTEMA EN LÃNEA</b>
// El servidor se ha reiniciado correctamente.

// ðŸ“‹ <b>Comandos Disponibles:</b>

// ðŸ“Š /monthly - Reporte del Mes
// ðŸ“ˆ /yearly - Reporte del AÃ±o
// â“ /help - Ayuda
//             `;
//             const admins = await prisma.users.findMany({ where: { role: 'admin', telegram_chat_id: { not: null } } });
//             admins.forEach(u => safeReply(u.telegram_chat_id, startMsg));
//         })
//         .catch((err) => {
//             console.error("âŒ Telegram Connection Warning:", err.message);
//         });

//       // Graceful Stop
//       process.once('SIGINT', () => bot.stop('SIGINT'));
//       process.once('SIGTERM', () => bot.stop('SIGTERM'));

//   } catch (error) {
//       console.error("âŒ Critical Error initializing Bot:", error.message);
//       isBotRunning = false;
//       bot = null;
//   }
// };


// export const initTelegramBot = async () => {
//   try {
//     const config = await prisma.system_configuration.findFirst();

//     if (!config || !config.telegram_bot_token) {
//       console.warn("âš ï¸ Telegram Bot Token not configured.");
//       return;
//     }

//     bot = new Telegraf(config.telegram_bot_token);

//     bot.catch((err) => console.error("âŒ Telegram Runtime Error:", err));

//     setupCommands();

//     console.log("â³ Iniciando bot de Telegram...");

//     // ðŸ”¥ ESTA ES LA CLAVE: usar await
//     await bot.launch();

//     console.log("ðŸ¤– Bot conectado a Telegram");
//     isBotRunning = true;

//     // ðŸ“¢ Mensaje inicial a admins
//     const startMsg = `
// ðŸŸ¢ <b>SISTEMA EN LÃNEA</b>
// El servidor se ha reiniciado correctamente.

// ðŸ“‹ <b>Comandos Disponibles:</b>

// ðŸ“Š /monthly - Reporte del Mes
// ðŸ“ˆ /yearly - Reporte del AÃ±o
// â“ /help - Ayuda
//     `;

//     const admins = await prisma.users.findMany({
//       where: { role: 'admin', telegram_chat_id: { not: null } }
//     });

//     for (const u of admins) {
//       await safeReply(u.telegram_chat_id, startMsg);
//     }

//     process.once('SIGINT', () => bot.stop('SIGINT'));
//     process.once('SIGTERM', () => bot.stop('SIGTERM'));

//   } catch (error) {
//     console.error("âŒ Critical Error initializing Bot:", error.message);
//     isBotRunning = false;
//     bot = null;
//   }
// };


// export const initTelegramBot = async () => {
//   try {
//     const config = await prisma.system_configuration.findFirst();

//     if (!config || !config.telegram_bot_token) {
//       console.warn("âš ï¸ Telegram Bot Token not configured.");
//       return;
//     }

//     bot = new Telegraf(config.telegram_bot_token);

//     bot.catch((err) => console.error("âŒ Telegram Runtime Error:", err));

//     setupCommands();

//     console.log("â³ Iniciando bot de Telegram...");

//     // ðŸš€ Lanzar el bot SIN bloquear el event loop
//     bot.launch()
//       .then(async () => {
//         console.log("ðŸ¤– Bot conectado a Telegram");

//         const startMsg = `
// ðŸŸ¢ <b>SISTEMA EN LÃNEA</b>
// El servidor se ha reiniciado correctamente.

// ðŸ“‹ <b>Comandos Disponibles:</b>

// ðŸ“Š /monthly - Reporte del Mes
// ðŸ“ˆ /yearly - Reporte del AÃ±o
// â“ /help - Ayuda
//         `;

//         const admins = await prisma.users.findMany({
//           where: { role: 'admin', telegram_chat_id: { not: null } }
//         });

//         for (const u of admins) {
//           await safeReply(u.telegram_chat_id, startMsg);
//         }
//       })
//       .catch((err) => {
//         console.error("âŒ Error iniciando bot:", err.message);
//       });

//     // ðŸ›‘ Cierre elegante
//     process.once('SIGINT', () => bot.stop('SIGINT'));
//     process.once('SIGTERM', () => bot.stop('SIGTERM'));

//   } catch (error) {
//     console.error("âŒ Critical Error initializing Bot:", error.message);
//   }
// };

export const initTelegramBot = async () => {
  try {
    const config = await prisma.system_configuration.findFirst();

    if (!config || !config.telegram_bot_token) {
      console.warn("âš ï¸ Telegram Bot Token not configured.");
      return;
    }

    bot = new Telegraf(config.telegram_bot_token, {
      telegram: { apiRoot: "https://api.telegram.org" },
      handlerTimeout: 30000
    });

    bot.catch((err) => console.error("âŒ Telegram Runtime Error:", err));

    setupCommands();

    //console.log("â³ Iniciando bot de Telegram...");

    // ðŸš€ Lanzar sin await y forzando polling puro
    bot.launch({
      dropPendingUpdates: true,
      polling: {
        timeout: 30,
        limit: 100
      }
    });

    console.log("ðŸ¤– Telegram bot running ðŸš€");

    // Mensaje inicial
    const initMsg = `
ðŸ¤– <b> Habana Express Bot ðŸš€ </b>
    `;

    const strHelp = `
ðŸ“‹ <b>Comandos Disponibles:</b>
ðŸ“Š /monthly - Reporte del Mes
ðŸ“ˆ /yearly - Reporte del AÃ±o
â“ /help - Ayuda`

    const admins = await prisma.users.findMany({
      where: { role: 'admin', telegram_chat_id: { not: null } }
    });

    for (const u of admins) {
      await safeReply(u.telegram_chat_id, initMsg);
      await safeReply(u.telegram_chat_id, strHelp);
    }

    process.once('SIGINT', () => bot.stop('SIGINT'));
    process.once('SIGTERM', () => bot.stop('SIGTERM'));

  } catch (error) {
    console.error("âŒ Critical Error initializing Bot:", error.message);
  }
};




// --- ðŸ”” NOTIFICATIONS ---

// 1. NOTIFY NEW SALE
export const notifySale = async (sale) => {
  if (!bot) return;

  try {
      const config = await prisma.system_configuration.findFirst();
      const commissionPct = Number(config.seller_commission_percentage);
      const exchangeRate = Number(sale.exchange_rate);
      
      const totalSaleUSD = Number(sale.total_cup) / exchangeRate;
      let totalProductCostUSD = 0;
      let productList = "";
      
      sale.sale_products.forEach(item => {
          totalProductCostUSD += (Number(item.product.purchase_price) * item.quantity);
          productList += `ðŸ“¦ ${item.product.name} (x${item.quantity})\n`;
      });

      const commissionUSD = totalSaleUSD * (commissionPct / 100);
      const netProfitUSD = totalSaleUSD - totalProductCostUSD - commissionUSD;

      const totalSaleCUP = Number(sale.total_cup);
      const netProfitCUP = netProfitUSD * exchangeRate;
      const commissionCUP = commissionUSD * exchangeRate;

      const adminMsg = `
ðŸ’µ <b>NUEVA VENTA</b> | ${sale.seller.name}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${productList}
ðŸ’° <b>Ingreso Total</b>
<b>(CUP)</b> ${formatNumber(totalSaleCUP)}
<b>(USD)</b> ${formatNumber(totalSaleUSD)}

â‡ï¸ <b>Ganancia Neta</b>
<b>(CUP)</b> ${formatNumber(netProfitCUP)}
<b>(USD)</b> ${formatNumber(netProfitUSD)}
      `;

      const sellerMsg = `
ðŸ’µ <b>VENTA REGISTRADA</b>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${productList}
ðŸ’¸ <b>Tu ComisiÃ³n:</b>
<b>(CUP)</b> +${formatNumber(commissionCUP)}

ðŸ”¥ <i>Â¡Seguimos sumando!</i>
      `;

      const admins = await prisma.users.findMany({ where: { role: 'admin', telegram_chat_id: { not: null } } });
      admins.forEach(u => safeReply(u.telegram_chat_id, adminMsg));
      
      if (sale.seller.telegram_chat_id) {
          safeReply(sale.seller.telegram_chat_id, sellerMsg);
      }

  } catch (error) { console.error("Notify Sale Error:", error.message); }
};

// 2. NOTIFY STOCK DEPLETION (Strict Financial Calculation)
export const notifyStockDepletion = async (product) => {
  if (!bot) return;
  try {
    const config = await prisma.system_configuration.findFirst();
    const commissionPct = config ? Number(config.seller_commission_percentage) : 0;

    const salesHistory = await prisma.sale_products.findMany({
        where: { id_product: product.id_product },
        include: { sale: true }
    });

    let totalQuantitySold = 0;
    
    // Calculate Total Quantity
    salesHistory.forEach(item => {
        totalQuantitySold += item.quantity;
    });

    // 1. Total Investment (Costo real de la mercancÃ­a)
    const purchasePrice = Number(product.purchase_price);
    const totalInvestmentUSD = purchasePrice * totalQuantitySold;

    // 2. Revenue Calculation (Pricing Rule: Cost * 2)
    // Assumption: Sales were made following the rule.
    const totalRevenueUSD = totalInvestmentUSD * 2;

    // 3. Commissions Paid
    const totalCommissionsUSD = totalRevenueUSD * (commissionPct / 100);

    // 4. Net Profit
    const netProfitUSD = totalRevenueUSD - totalInvestmentUSD - totalCommissionsUSD;

    const msg = `
ðŸ“‰ <b>STOCK AGOTADO</b>
Se vendieron todos los <b>${product.name}</b>

ðŸ“Š <b>Resumen del Lote:</b>

ðŸ“¦ <b>Unidades Vendidas:</b> ${totalQuantitySold}

ðŸ’° <b>Costo de InversiÃ³n</b>
<b>(USD)</b> ${formatNumber(totalInvestmentUSD)}
<i>(${totalQuantitySold} unid. x $${formatNumber(purchasePrice)} costo)</i>

âœ… <b>Ganancia Neta</b>
<b>(USD)</b> ${formatNumber(netProfitUSD)}
<i>(Descontando comisiones)</i>
    `;

    const admins = await prisma.users.findMany({ where: { role: 'admin', telegram_chat_id: { not: null } } });
    admins.forEach(u => safeReply(u.telegram_chat_id, msg));

  } catch (error) { console.error("Notify Stock Error:", error.message); }
};

// 3. NOTIFY DAILY UPDATE (ADMIN)
export const notifyDailyUpdate = async (newRate, productsCount) => {
    if (!bot) return;
    try {
        const msg = `
ðŸ¤– <b>SincronizaciÃ³n Diaria Completada</b>

âœ… <b>Nueva Tasa:</b> ${newRate} CUP
ðŸ“Š <b>Productos actualizados:</b> ${productsCount}
ðŸ“¨ <b>Vendedores notificados.</b>
        `;
        const admins = await prisma.users.findMany({ where: { role: 'admin', telegram_chat_id: { not: null } } });
        admins.forEach(u => safeReply(u.telegram_chat_id, msg));
    } catch (e) { console.error(e); }
};

// 4. NOTIFY DAILY PRICES (SELLER)
export const notifyDailyPrices = async (seller, newRate) => {
    if (!bot || !seller.telegram_chat_id) return;
    try {
        let msg = `
ðŸŒ… <b>Buenos dÃ­as, ${seller.name}</b>

ðŸ’± <b>Tasa del dÃ­a:</b> ${newRate} CUP
ðŸ“‹ <b>Tus Productos Actualizados:</b>
`;
        seller.seller_products.forEach(sp => {
            const priceNow = Number(sp.product.purchase_price) * 2 * newRate;
            msg += `
ðŸ“¦ <b>${sp.product.name}</b>
<b>(CUP)</b> ${formatNumber(priceNow)}
ðŸŽ’ Stock: ${sp.quantity}
`;
        });
        msg += `\nðŸš€ <i>Â¡Ã‰xito en las ventas de hoy!</i>`;
        safeReply(seller.telegram_chat_id, msg);
    } catch (e) { console.error(e); }
};

// 5. NOTIFY RETURN
export const notifyReturn = async (returnData) => {
    if (!bot) return;
    try {
        const msg = `
âŒ <b>DEVOLUCIÃ“N</b>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ“¦ <b>Producto:</b> ${returnData.product.name}
ðŸ”¢ <b>Cant:</b> ${returnData.quantity}
ðŸ“ <b>Motivo:</b> ${returnData.reason || 'No especificado'}

ðŸ“‰ <b>PÃ©rdida:</b>
<b>(USD)</b> -${formatNumber(returnData.loss_usd)}

        `;
        const recipients = await prisma.users.findMany({
          where: { role: { in: ['admin'] }, telegram_chat_id: { not: null } }
        });
        recipients.forEach(u => safeReply(u.telegram_chat_id, msg));
    } catch (e) { console.error(e); }
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\services\exchangeRate.js
============================================
import axios from "axios";

const API_URL = "https://www.cambiocup.com/api";

export const getDailyExchangeRate = async () => {
  try {
    console.log("ðŸ”„ Fetching Exchange Rate from API...");

    const { data } = await axios.get(API_URL, {
      headers: {
        "User-Agent": "Mozilla/5.0",
        "Accept": "application/json"
      },
      timeout: 8000
    });

    // Validamos que exista la estructura esperada
    const latest = data.cupHistory?.[0]?.value;

    if (!latest) {
      throw new Error("API did not return valid data in cupHistory[0].value");
    }

    // Regla de Negocio: Redondeo a la decena mÃ¡s cercana
    // Ejemplo: 514 -> 510, 515 -> 520
    const finalRate = Math.round(latest / 10) * 10;

    console.log(`âœ… Current Rate: ${latest} | Rounded Rate: ${finalRate}`);

    return finalRate;

  } catch (error) {
    console.error("âŒ Error fetching exchange rate:", error.message);
    return null; // Retornamos null para manejar el error en el Cron Job
  }
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\services\finance.js
============================================
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Helper: Redondeo estÃ¡ndar a entero (sin decimales)
// Ej: 10.4 -> 10, 10.5 -> 11
const roundInt = (val) => Math.round(Number(val));

/**
 * LÃ³gica central de cÃ¡lculo financiero
 */
const calculateProfitInPeriod = async (startDate, endDate) => {
  // 1. Obtener ConfiguraciÃ³n (para % de comisiÃ³n)
  const config = await prisma.system_configuration.findFirst();
  const commissionPct = config ? Number(config.seller_commission_percentage) : 0;

  // 2. Consultas a BD
  const sales = await prisma.sales.findMany({
    where: { sale_date: { gte: startDate, lte: endDate } },
  });

  const shipments = await prisma.shipments.findMany({
    where: { shipment_date: { gte: startDate, lte: endDate } },
  });

  const returns = await prisma.returns.findMany({
    where: { return_date: { gte: startDate, lte: endDate } },
  });

  // 3. --- INGRESOS (INCOME) ---
  let totalIncomeUSD = 0;
  sales.forEach(sale => {
    const rate = Number(sale.exchange_rate);
    const cup = Number(sale.total_cup);
    if (rate > 0) totalIncomeUSD += cup / rate;
  });

  // 4. --- COSTOS DE INVERSIÃ“N (INVESTMENT) ---
  let totalInvestmentUSD = 0;
  shipments.forEach(ship => {
    const shipping = Number(ship.shipping_cost_usd);
    const merch = Number(ship.merchandise_cost_usd);
    const customsCup = Number(ship.customs_fee_cup);
    const rate = Number(ship.exchange_rate);
    const customsUsd = rate > 0 ? customsCup / rate : 0;

    totalInvestmentUSD += (shipping + merch + customsUsd);
  });

  // 5. --- PÃ‰RDIDAS OPERATIVAS (RETURNS) ---
  let returnLossesUSD = 0;
  returns.forEach(ret => {
    returnLossesUSD += Number(ret.loss_usd);
  });

  // 6. --- COMISIONES VENDEDORES ---
  const totalCommissionsUSD = totalIncomeUSD * (commissionPct / 100);

  // 7. --- GANANCIA NETA (Sin Diezmo) ---
  const netProfit = totalIncomeUSD - (totalInvestmentUSD + returnLossesUSD + totalCommissionsUSD);

  // ðŸ”¥ RETORNAMOS VALORES REDONDEADOS A ENTEROS
  return {
    income: roundInt(totalIncomeUSD),
    investment: roundInt(totalInvestmentUSD),
    returnLosses: roundInt(returnLossesUSD),
    commissions: roundInt(totalCommissionsUSD),
    netProfit: roundInt(netProfit)
  };
};

/**
 * Reporte Mensual
 */
export const getMonthlyReport = async () => {
  const now = new Date();
  const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  
  const data = await calculateProfitInPeriod(startOfMonth, now);
  
  return {
    period: "Mensual",
    month: now.getMonth() + 1,
    year: now.getFullYear(),
    ...data
  };
};

/**
 * Reporte Anual
 */
export const getAnnualReport = async () => {
  const now = new Date();
  const startOfYear = new Date(now.getFullYear(), 0, 1);
  
  // 1. Totales Globales (Redondeados)
  const globalData = await calculateProfitInPeriod(startOfYear, now);

  // 2. Desglose para GrÃ¡ficos
  const breakdown = [];
  for (let i = 0; i < 12; i++) {
    const start = new Date(now.getFullYear(), i, 1);
    const end = new Date(now.getFullYear(), i + 1, 0, 23, 59, 59);
    if (start > now) break;

    const monthData = await calculateProfitInPeriod(start, end);
    
    // ROI se deja con 2 decimales porque es un porcentaje (ej: 12.5%)
    let roi = 0;
    if (monthData.investment > 0) {
      roi = (monthData.netProfit / monthData.investment) * 100;
    }

    breakdown.push({
      month: i + 1,
      investment: monthData.investment, // Ya viene redondeado
      profit: monthData.netProfit,      // Ya viene redondeado
      roiPercentage: parseFloat(roi.toFixed(2)) // Mantenemos decimales solo en ROI
    });
  }

  return {
    period: "Anual",
    year: now.getFullYear(),
    ...globalData, 
    breakdown: breakdown,
    totalNetProfit: globalData.netProfit
  };
};

/**
 * Ranking de Mejores Vendedores
 */
export const calculateTopSellers = async (period) => {
  const now = new Date();
  let startDate;

  if (period === 'month') {
    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
  } else {
    startDate = new Date(now.getFullYear(), 0, 1);
  }

  const sales = await prisma.sales.findMany({
    where: { sale_date: { gte: startDate } },
    include: { seller: true, sale_products: true }
  });

  const sellerStats = {};

  sales.forEach(sale => {
    const sellerId = sale.id_seller;
    const rate = Number(sale.exchange_rate);
    const cup = Number(sale.total_cup);
    const usdAmount = rate > 0 ? cup / rate : 0;
    
    const itemsCount = sale.sale_products.reduce((acc, item) => acc + item.quantity, 0);

    if (!sellerStats[sellerId]) {
      sellerStats[sellerId] = {
        id_user: sellerId,
        name: sale.seller.name,
        photo_url: sale.seller.photo_url,
        total_sales_usd: 0,
        items_sold: 0
      };
    }

    sellerStats[sellerId].total_sales_usd += usdAmount;
    sellerStats[sellerId].items_sold += itemsCount;
  });

  const ranking = Object.values(sellerStats)
    .sort((a, b) => b.total_sales_usd - a.total_sales_usd)
    .map(seller => ({
        ...seller,
        // ðŸ”¥ Redondeamos el total vendido aquÃ­
        total_sales_usd: roundInt(seller.total_sales_usd)
    }));

  return ranking;
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\services\scheduler.js
============================================
import cron from 'node-cron';
import { PrismaClient } from '@prisma/client';
import { getDailyExchangeRate } from './exchangeRate.js';
import { notifyDailyUpdate, notifyDailyPrices } from '../telegram.js';

const prisma = new PrismaClient();

/**
 * Core Logic: Daily Price Update
 * 1. Fetch Rate. 2. Update Config. 3. Update Prices. 4. Notify.
 */
export const executeDailyUpdate = async () => {
  console.log("â° Starting Daily Price Update Routine...");

  try {
    // 1. Fetch Rate
    const newRate = await getDailyExchangeRate();
    if (!newRate) return;

    // 2. Update System Config
    const config = await prisma.system_configuration.findFirst();
    if (config) {
      await prisma.system_configuration.update({
        where: { id_config: config.id_config },
        data: { default_exchange_rate: newRate }
      });
    }

    // 3. Bulk Update Prices (Active Products)
    const products = await prisma.products.findMany({ where: { active: true } });
    
    if (products.length > 0) {
        const updatePromises = products.map(product => {
            const cost = Number(product.purchase_price);
            // Formula: Cost * 2 * Rate
            const newSalePrice = cost * 2 * newRate;
            return prisma.products.update({
                where: { id_product: product.id_product },
                data: { sale_price: newSalePrice }
            });
        });

        await prisma.$transaction(updatePromises);
        console.log(`âœ… Prices updated for ${products.length} products.`);

        // 4. Notify Admin (Process Summary)
        await notifyDailyUpdate(newRate, products.length);

        // 5. Notify Sellers (Price List)
        const sellers = await prisma.users.findMany({
            where: { role: 'seller', active: true, telegram_chat_id: { not: null } },
            include: { seller_products: { include: { product: true } } }
        });

        for (const seller of sellers) {
            if (seller.seller_products.length > 0) {
                await notifyDailyPrices(seller, newRate);
            }
        }
    }

  } catch (error) {
    console.error("âŒ CRITICAL ERROR during daily update:", error);
  }
};

/**
 * Scheduler Initialization
 * Checks every minute if current Havana time matches DB configuration.
 */
export const initScheduler = () => {
  console.log("ðŸ“… Initializing Dynamic Scheduler...");

  cron.schedule('* * * * *', async () => {
    try {
        const config = await prisma.system_configuration.findFirst();
        if (!config || !config.exchange_rate_sync_time) return;

        const now = new Date();
        const cubaTime = new Date(now.toLocaleString("en-US", { timeZone: "America/Havana" }));
        
        // Config time is usually UTC in Prisma/DB, so we compare logic manually or via UTC match
        const targetTime = new Date(config.exchange_rate_sync_time);

        // Simple Hour/Minute matching
        const currentHour = cubaTime.getHours();
        const currentMinute = cubaTime.getMinutes();
        const targetHour = targetTime.getUTCHours(); 
        const targetMinute = targetTime.getUTCMinutes();

        if (currentHour === targetHour && currentMinute === targetMinute) {
             console.log(`âš¡ It's ${currentHour}:${currentMinute} (Havana). Executing Daily Update...`);
             await executeDailyUpdate();
        }

    } catch (error) {
        console.error("Scheduler Error:", error.message);
    }
  });

  console.log("âœ… Scheduler is running.");
};.
.
