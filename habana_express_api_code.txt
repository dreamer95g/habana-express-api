============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\.env
============================================


DATABASE_URL="mysql://root:root@localhost:3306/habana_express_store"
PORT=4000

JWT_SECRET="Gabry123"

# üëá AGREGA ESTO
CLOUDINARY_CLOUD_NAME="ddnqbgqfn"
CLOUDINARY_API_KEY="714472522733682"
CLOUDINARY_API_SECRET="S1cBDX5f9_Ox5ncFVl4slpgKTZk"

============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\habana_express_store.sql
============================================
/*
Navicat MySQL Data Transfer

Source Server         : MySQL
Source Server Version : 50724
Source Host           : 127.0.0.1:3306
Source Database       : habana_express_store

Target Server Type    : MYSQL
Target Server Version : 50724
File Encoding         : 65001

Date: 2026-01-15 16:09:02
*/

SET FOREIGN_KEY_CHECKS=0;


-- --------------------------------------------------------
-- üì¶ HABANA EXPRESS STORE - ESTRUCTURA FINAL 2026
-- --------------------------------------------------------

-- 1. Crear Base de Datos con soporte para Emojis
DROP DATABASE IF EXISTS habana_express_store;
CREATE DATABASE habana_express_store
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_unicode_ci;

USE habana_express_store;


-- ----------------------------
-- Table structure for categories
-- ----------------------------
DROP TABLE IF EXISTS `categories`;
CREATE TABLE `categories` (
  `id_category` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `active` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id_category`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for products
-- ----------------------------
DROP TABLE IF EXISTS `products`;
CREATE TABLE `products` (
  `id_product` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `purchase_price` decimal(10,2) NOT NULL,
  `sale_price` decimal(10,2) NOT NULL,
  `stock` int(11) NOT NULL DEFAULT '0',
  `sku` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `supplier_name` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `date_added` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `active` tinyint(1) NOT NULL DEFAULT '1',
  `photo_url` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `warranty` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id_product`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for product_categories
-- ----------------------------
DROP TABLE IF EXISTS `product_categories`;
CREATE TABLE `product_categories` (
  `id_product_category` int(11) NOT NULL AUTO_INCREMENT,
  `id_product` int(11) NOT NULL,
  `id_category` int(11) NOT NULL,
  PRIMARY KEY (`id_product_category`),
  KEY `product_categories_id_category_fkey` (`id_category`),
  KEY `product_categories_id_product_fkey` (`id_product`),
  CONSTRAINT `product_categories_id_category_fkey` FOREIGN KEY (`id_category`) REFERENCES `categories` (`id_category`) ON UPDATE CASCADE,
  CONSTRAINT `product_categories_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products` (`id_product`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for returns
-- ----------------------------
DROP TABLE IF EXISTS `returns`;
CREATE TABLE `returns` (
  `id_return` int(11) NOT NULL AUTO_INCREMENT,
  `id_sale` int(11) NOT NULL,
  `id_product` int(11) NOT NULL,
  `quantity` int(11) NOT NULL,
  `return_date` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `loss_usd` decimal(12,2) NOT NULL,
  `reason` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id_return`),
  KEY `returns_id_product_fkey` (`id_product`),
  KEY `returns_id_sale_fkey` (`id_sale`),
  CONSTRAINT `returns_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products` (`id_product`) ON UPDATE CASCADE,
  CONSTRAINT `returns_id_sale_fkey` FOREIGN KEY (`id_sale`) REFERENCES `sales` (`id_sale`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for sales
-- ----------------------------
DROP TABLE IF EXISTS `sales`;
CREATE TABLE `sales` (
  `id_sale` int(11) NOT NULL AUTO_INCREMENT,
  `sale_date` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `exchange_rate` decimal(10,4) NOT NULL,
  `total_cup` decimal(12,2) NOT NULL,
  `buyer_phone` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `notes` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `payment_method` enum('cash','transfer') COLLATE utf8mb4_unicode_ci NOT NULL,
  `id_seller` int(11) NOT NULL,
  PRIMARY KEY (`id_sale`),
  KEY `sales_id_seller_fkey` (`id_seller`),
  CONSTRAINT `sales_id_seller_fkey` FOREIGN KEY (`id_seller`) REFERENCES `users` (`id_user`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for sale_products
-- ----------------------------
DROP TABLE IF EXISTS `sale_products`;
CREATE TABLE `sale_products` (
  `id_sale_product` int(11) NOT NULL AUTO_INCREMENT,
  `id_sale` int(11) NOT NULL,
  `id_product` int(11) NOT NULL,
  `quantity` int(11) NOT NULL,
  PRIMARY KEY (`id_sale_product`),
  KEY `sale_products_id_product_fkey` (`id_product`),
  KEY `sale_products_id_sale_fkey` (`id_sale`),
  CONSTRAINT `sale_products_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products` (`id_product`) ON UPDATE CASCADE,
  CONSTRAINT `sale_products_id_sale_fkey` FOREIGN KEY (`id_sale`) REFERENCES `sales` (`id_sale`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for seller_products
-- ----------------------------
DROP TABLE IF EXISTS `seller_products`;
CREATE TABLE `seller_products` (
  `id_seller_product` int(11) NOT NULL AUTO_INCREMENT,
  `id_seller` int(11) NOT NULL,
  `id_product` int(11) NOT NULL,
  `quantity` int(11) NOT NULL DEFAULT '0',
  `assigned_at` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  PRIMARY KEY (`id_seller_product`),
  KEY `seller_products_id_product_fkey` (`id_product`),
  KEY `seller_products_id_seller_fkey` (`id_seller`),
  CONSTRAINT `seller_products_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products` (`id_product`) ON UPDATE CASCADE,
  CONSTRAINT `seller_products_id_seller_fkey` FOREIGN KEY (`id_seller`) REFERENCES `users` (`id_user`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for shipments
-- ----------------------------
DROP TABLE IF EXISTS `shipments`;
CREATE TABLE `shipments` (
  `id_shipment` int(11) NOT NULL AUTO_INCREMENT,
  `agency_name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `shipment_date` date NOT NULL,
  `shipping_cost_usd` decimal(12,2) NOT NULL,
  `merchandise_cost_usd` decimal(12,2) NOT NULL,
  `customs_fee_cup` decimal(12,2) NOT NULL,
  `exchange_rate` decimal(10,4) NOT NULL,
  `notes` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id_shipment`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for system_configuration
-- ----------------------------
DROP TABLE IF EXISTS `system_configuration`;
CREATE TABLE `system_configuration` (
  `id_config` int(11) NOT NULL AUTO_INCREMENT,
  `company_name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `company_phone` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `company_email` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `logo_url` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `description` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `seller_commission_percentage` decimal(5,2) NOT NULL,
  `monthly_report_day` int(11) DEFAULT NULL,
  `monthly_report_time` time DEFAULT NULL,
  `annual_report_day` int(11) DEFAULT NULL,
  `annual_report_time` time DEFAULT NULL,
  `default_exchange_rate` decimal(10,4) NOT NULL,
  `telegram_bot_token` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `active` tinyint(1) NOT NULL DEFAULT '1',
  `exchange_rate_sync_time` time DEFAULT NULL,
  PRIMARY KEY (`id_config`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `id_user` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `phone` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `photo_url` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `password_hash` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `telegram_chat_id` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `role` enum('admin','seller','storekeeper') COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `active` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id_user`),
  UNIQUE KEY `phone` (`phone`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\package.json
============================================
{
  "name": "habana-express-api",
  "version": "1.0.0",
  "description": "Habana Express Store API",
  "main": "src/index.js",
  "type": "module",
  "scripts": {
    "dev": "nodemon src/index.js",
    "start": "node src/index.js",
    "prisma:generate": "prisma generate",
    "prisma:push": "prisma db push",
    "prisma:studio": "prisma studio"
  },
  "dependencies": {
    "@prisma/client": "^5.10.0",
    "apollo-server-express": "^3.13.0",
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "cloudinary": "^2.9.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.1",
    "express": "^4.18.2",
    "graphql": "^16.8.1",
    "jsonwebtoken": "^9.0.3",
    "multer": "^2.0.2",
    "node-cron": "^4.2.1",
    "telegraf": "^4.16.3"
  },
  "devDependencies": {
    "nodemon": "^3.0.3",
    "prisma": "^5.10.0"
  }
}


============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma.config.ts
============================================
// This file was generated by Prisma, and assumes you have installed the following:
// npm install --save-dev prisma dotenv
import "dotenv/config";
import { defineConfig } from "prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    url: process.env["DATABASE_URL"],
  },
});


============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\README.md
============================================
<div align="center">

  <h1>?? Habana Express API</h1>
  <h3>Sistema ERP para Importaci¢n, Log°stica y Finanzas en Cuba</h3>

  <p>
    <img src="https://img.shields.io/badge/Node.js-18.x-339933?style=flat-square&logo=node.js&logoColor=white" alt="NodeJS" />
    <img src="https://img.shields.io/badge/GraphQL-Apollo-E10098?style=flat-square&logo=graphql&logoColor=white" alt="GraphQL" />
    <img src="https://img.shields.io/badge/Prisma-ORM-2D3748?style=flat-square&logo=prisma&logoColor=white" alt="Prisma" />
    <img src="https://img.shields.io/badge/MySQL-DB-4479A1?style=flat-square&logo=mysql&logoColor=white" alt="MySQL" />
    <img src="https://img.shields.io/badge/Telegram-Bot-26A5E4?style=flat-square&logo=telegram&logoColor=white" alt="Telegram" />
  </p>

  <p>
    <b>Soluci¢n Backend integral para superar las barreras del comercio con doble moneda.</b>
    <br>
    <i>Gesti¢n de inventario descentralizada, fijaci¢n de precios din†mica y reportes financieros automatizados.</i>
  </p>

</div>

<hr>

## ?? Descripci¢n del Proyecto

**Habana Express API** no es solo un gestor de inventario; es un motor financiero dise§ado para el contexto cubano. El sistema automatiza la compleja relaci¢n entre el costo de importaci¢n (USD), la tasa de cambio fluctuante (CUP) y la gesti¢n de vendedores comisionistas.

Su n£cleo integra un **Bot de Telegram** que act£a como asistente administrativo, eliminando la necesidad de paneles webs complejos para la operaci¢n diaria.

---

## ?? Caracter°sticas Clave

### 1. ?? Finanzas & Doble Moneda
*   **Fijaci¢n de Precios Din†mica:** El sistema consulta diariamente APIs externas para obtener la tasa de cambio actual.
*   **Algoritmo de Precios:** Recalcula autom†ticamente el precio de venta en CUP de todo el inventario activo bas†ndose en la f¢rmula: `Costo USD * 2 * Tasa del D°a`.
*   **C†lculo de Ganancia Real:** Reportes que descuentan costos de env°o, aranceles aduanales, pÇrdidas por devoluciones y comisiones de vendedores.

### 2. ?? Log°stica & Inventario
*   **Inventario en Consignaci¢n:** Distinci¢n entre **Stock Global** (AlmacÇn) y **Stock Asignado** (Vendedor). Un vendedor solo puede vender lo que se le ha asignado.
*   **Stock Reactivo:**
    *   Si el stock llega a `0`, el producto se desactiva autom†ticamente.
    *   Notificaci¢n autom†tica de "Liquidaci¢n de Lote" con an†lisis de rentabilidad final.

### 3. ?? Integraci¢n Profunda con Telegram
El sistema "habla" con los usuarios seg£n su rol:
*   **Admin:** Recibe reportes financieros (ROI), alertas de stock agotado y resumen de ganancias netas por venta.
*   **Vendedores:** Reciben cada ma§ana su lista de precios actualizada seg£n la tasa del d°a y notificaciones de sus comisiones ganadas.

---

## ??? Stack Tecnol¢gico

| Componente | Tecnolog°a | Uso |
| :--- | :--- | :--- |
| **Server** | Node.js + Express | Servidor HTTP y manejo de archivos est†ticos. |
| **API** | Apollo Server (GraphQL) | Endpoint £nico tipado para consultas y mutaciones. |
| **ORM** | Prisma | Modelado de datos y migraciones seguras a MySQL. |
| **Database** | MySQL | Almacenamiento relacional con soporte UTF8MB4. |
| **Automation** | Node-Cron + Axios | Scraping de tasas de cambio y tareas programadas. |
| **Bot** | Telegraf | Interfaz de chat para comandos y notificaciones push. |

---

## ?? L¢gica Financiera (Profit Formula)

El sistema prioriza la **transparencia financiera**. La ganancia neta no es una estimaci¢n, es un c†lculo exacto:

Ganancia Neta = Ingresos Totales - (Costo Mercanc°a + Env°os + Aranceles + PÇrdidas Devoluci¢n + Comisiones Vendedor)

Nota: El sistema aplica redondeos inteligentes a las decenas en la tasa de cambio (ej: 314 -> 310, 316 -> 320) para facilitar el manejo de efectivo en CUP.

?? Instalaci¢n y Despliegue
1. Requisitos Previos
Node.js v18+
MySQL Server corriendo localmente o en nube.
2. Clonar y Dependencias

git clone https://github.com/tu-usuario/habana-express-api.git
cd habana-express-api
npm install

3. Configuraci¢n de Entorno (.env)
Crea un archivo .env en la ra°z:

DATABASE_URL="mysql://user:pass@localhost:3306/habana_express_store"
PORT=4000
JWT_SECRET="TU_SECRETO_SEGURO"

4. Base de Datos
Inicializa el esquema y carga los datos de prueba (Admin, Seller, Storekeeper):

npx prisma db push
node prisma/seed.js

5. Iniciar Servidor
# Modo Desarrollo (con nodemon)
npm run dev

# Modo Producci¢n
npm start

Accede al Playground de GraphQL en: http://localhost:4000/graphql

?? Comandos del Bot (Telegram)
Una vez configurado el telegram_bot_token en la base de datos:
Comando	Descripci¢n
/monthly	Genera el Estado de Resultados del Mes actual (Ingresos vs Gastos vs ROI).
/yearly	Genera el Reporte Anual con desglose mes a mes.
/help	Muestra la lista de comandos disponibles.

?? Ejemplo de Uso (GraphQL)
Registrar una Venta

mutation {
  createSale(
    sellerId: 2,
    exchange_rate: 320.00,
    total_cup: 64000.00,
    buyer_phone: "55555555",
    payment_method: cash,
    items: [
      { productId: 1, quantity: 1 }
    ]
  ) {
    id_sale
    total_cup
    sale_products {
      product {
        name
      }
    }
  }
}

Consultar Reporte Financiero Anual
query {
  annualReport {
    year
    totalNetProfit
    breakdown {
      month
      investment
      profit
      roiPercentage
    }
  }
}

<div align="center">
<p>Desarrollado para <b>Habana Express Store</b></p>
<p>2026 &bull; Licencia ISC</p>
</div>

============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma\schema.prisma
============================================
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model system_configuration {
  id_config                    Int       @id @default(autoincrement())
  company_name                 String
  company_phone                String?
  company_email                String?
  logo_url                     String?
  description                  String?
  seller_commission_percentage Decimal   @db.Decimal(5, 2)
  
  // ‚ú® NUEVO CAMPO: Hora de sincronizaci√≥n de tasa (Ej: 08:00:00)
  exchange_rate_sync_time      DateTime? @db.Time(0)

  monthly_report_day           Int?
  monthly_report_time          DateTime? @db.Time(0)
  annual_report_day            Int?
  annual_report_time           DateTime? @db.Time(0)
  
  default_exchange_rate        Decimal   @db.Decimal(10, 4)
  telegram_bot_token           String
  created_at                   DateTime  @default(now())
  active                       Boolean   @default(true)
}

model users {
  id_user          Int               @id @default(autoincrement())
  name             String
  phone            String            @unique
  email            String?
  photo_url        String?
  password_hash    String
  telegram_chat_id String?
  role             Role
  created_at       DateTime          @default(now())
  active           Boolean           @default(true)
  sales            sales[]
  seller_products  seller_products[]
}

model products {
  id_product         Int                  @id @default(autoincrement())
  name               String
  description        String?
  purchase_price     Decimal              @db.Decimal(10, 2)
  sale_price         Decimal              @db.Decimal(10, 2)
  stock              Int                  @default(0)
  sku                String?
  supplier_name      String?
  date_added         DateTime             @default(now())
  active             Boolean              @default(true)
  photo_url          String?
  warranty           Boolean              @default(false)
  product_categories product_categories[]
  returns            returns[]
  sale_products      sale_products[]
  seller_products    seller_products[]
}

model categories {
  id_category        Int                  @id @default(autoincrement())
  name               String
  active             Boolean              @default(true)
  product_categories product_categories[]
}

model product_categories {
  id_product_category Int        @id @default(autoincrement())
  id_product          Int
  id_category         Int
  category            categories @relation(fields: [id_category], references: [id_category])
  product             products   @relation(fields: [id_product], references: [id_product])

  @@index([id_category], map: "product_categories_id_category_fkey")
  @@index([id_product], map: "product_categories_id_product_fkey")
}


model sales {
  id_sale        Int             @id @default(autoincrement())
  sale_date      DateTime        @default(now())
  exchange_rate  Decimal         @db.Decimal(10, 4)
  total_cup      Decimal         @db.Decimal(12, 2)
  buyer_phone    String
  notes          String?
  payment_method PaymentMethod
  
  // ‚ú® NUEVO CAMPO
  status         SaleStatus      @default(COMPLETED)

  id_seller      Int
  returns        returns[]
  sale_products  sale_products[]
  seller         users           @relation(fields: [id_seller], references: [id_user])

  @@index([id_seller], map: "sales_id_seller_fkey")
}


model sale_products {
  id_sale_product Int      @id @default(autoincrement())
  id_sale         Int
  id_product      Int
  quantity        Int
  product         products @relation(fields: [id_product], references: [id_product])
  sale            sales    @relation(fields: [id_sale], references: [id_sale])

  @@index([id_product], map: "sale_products_id_product_fkey")
  @@index([id_sale], map: "sale_products_id_sale_fkey")
}

model returns {
  id_return   Int      @id @default(autoincrement())
  id_sale     Int
  id_product  Int
  quantity    Int
  return_date DateTime @default(now())
  loss_usd    Decimal  @db.Decimal(12, 2)
  reason      String?
  product     products @relation(fields: [id_product], references: [id_product])
  sale        sales    @relation(fields: [id_sale], references: [id_sale])

  @@index([id_product], map: "returns_id_product_fkey")
  @@index([id_sale], map: "returns_id_sale_fkey")
}

model shipments {
  id_shipment          Int      @id @default(autoincrement())
  agency_name          String
  shipment_date        DateTime @db.Date
  shipping_cost_usd    Decimal  @db.Decimal(12, 2)
  merchandise_cost_usd Decimal  @db.Decimal(12, 2)
  customs_fee_cup      Decimal  @db.Decimal(12, 2)
  exchange_rate        Decimal  @db.Decimal(10, 4)
  notes                String?
}

model seller_products {
  id_seller_product Int      @id @default(autoincrement())
  id_seller         Int
  id_product        Int
  quantity          Int      @default(0)
  assigned_at       DateTime @default(now())
  product           products @relation(fields: [id_product], references: [id_product])
  seller            users    @relation(fields: [id_seller], references: [id_user])

  @@index([id_product], map: "seller_products_id_product_fkey")
  @@index([id_seller], map: "seller_products_id_seller_fkey")
}

enum Role {
  admin
  seller
  storekeeper
}

enum PaymentMethod {
  cash
  transfer
}

enum SaleStatus {
  COMPLETED
  CANCELLED
}.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma\seed.js
============================================
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs'; // Aseg√∫rate de tenerlo instalado: npm install bcryptjs

const prisma = new PrismaClient();

async function main() {
  console.log('üå± Iniciando Seed (Semilla de Datos)...');

  // 1. LIMPIEZA: Borrar datos antiguos (Orden espec√≠fico por llaves for√°neas)
  await prisma.returns.deleteMany();
  await prisma.sale_products.deleteMany();
  await prisma.sales.deleteMany();
  await prisma.seller_products.deleteMany();
  await prisma.product_categories.deleteMany();
  await prisma.products.deleteMany();
  await prisma.categories.deleteMany();
  await prisma.shipments.deleteMany();
  await prisma.users.deleteMany();
  await prisma.system_configuration.deleteMany();

  console.log('üßπ Base de datos limpiada.');

  // 2. HASHEAR PASSWORD (Usaremos '123456' para todos)
  const passwordHash = await bcrypt.hash('123456', 10);

  // 3. CONFIGURACI√ìN DEL SISTEMA
  // Fecha para reporte: 8:00 AM
  const reportTime = new Date();
  reportTime.setHours(8, 0, 0, 0);

  await prisma.system_configuration.create({
    data: {
      company_name: "Habana Express Store",
      company_phone: "+53 50000000",
      company_email: "contacto@habanaexpress.com",
      description: "Tienda de importaci√≥n y retail.",
      seller_commission_percentage: 10.00, // 10%
      default_exchange_rate: 520.00,       // Tasa 520
      telegram_bot_token: "8584827308:AAFL5AN7Made0xCe2uz2_0GwWRhBNvIaaqI", // Tu Token Real
      
      // Configuraci√≥n de Reportes
      monthly_report_day: 20,
      monthly_report_time: reportTime,
      annual_report_day: 20, // Diciembre se valida por c√≥digo, aqu√≠ guardamos el d√≠a
      annual_report_time: reportTime,
    }
  });
  console.log('‚öôÔ∏è Configuraci√≥n creada.');

  // 4. USUARIOS
  const admin = await prisma.users.create({
    data: {
      name: "Super Admin",
      phone: "50000001", // Login Admin
      email: "admin@test.com",
      password_hash: passwordHash,
      role: "admin",
      telegram_chat_id: "888319060", // TU CHAT ID REAL
      active: true
    }
  });

  const seller = await prisma.users.create({
    data: {
      name: "Vendedor Estrella",
      phone: "50000002", // Login Seller
      email: "seller@test.com",
      password_hash: passwordHash,
      role: "seller",
      telegram_chat_id: "123456789", // Fake ID
      active: true
    }
  });

  const storekeeper = await prisma.users.create({
    data: {
      name: "Jefe de Almac√©n",
      phone: "50000003", // Login Storekeeper
      email: "store@test.com",
      password_hash: passwordHash,
      role: "storekeeper",
      telegram_chat_id: "987654321", // Fake ID
      active: true
    }
  });
  console.log('üë• Usuarios creados (Admin, Seller, Storekeeper).');

  // 5. CATEGOR√çAS
  const catElec = await prisma.categories.create({ data: { name: "Electr√≥nica" } });
  const catHome = await prisma.categories.create({ data: { name: "Hogar" } });

  // 6. ENV√çO (INVERSI√ìN INICIAL)
  // Simulamos que trajimos mercanc√≠a para vender
  await prisma.shipments.create({
    data: {
      agency_name: "Aerovaradero",
      shipment_date: new Date(), // Fecha de hoy
      shipping_cost_usd: 150.00,
      merchandise_cost_usd: 1200.00, // Costo de los productos abajo
      customs_fee_cup: 5000.00,      // Aranceles
      exchange_rate: 520.00,
      notes: "Env√≠o inicial de prueba"
    }
  });
  console.log('‚úàÔ∏è Env√≠o de inversi√≥n creado.');

  // 7. PRODUCTOS
  // Prod 1: iPhone 13 (Costo $400)
  const product1 = await prisma.products.create({
    data: {
      name: "iPhone 13 Refurbished",
      description: "128GB, Bater√≠a 100%",
      purchase_price: 400.00, 
      sale_price: 900.00,    // Venta en USD (referencial)
      stock: 5,              // Stock inicial
      sku: "IPH13-128",
      active: true,
      warranty: true,
      product_categories: { create: { id_category: catElec.id_category } }
    }
  });

  // Prod 2: AirFryer (Costo $50)
  const product2 = await prisma.products.create({
    data: {
      name: "AirFryer Xiaomi 4L",
      description: "Freidora de aire inteligente",
      purchase_price: 50.00,
      sale_price: 120.00,
      stock: 10,
      sku: "AF-XIAOMI",
      active: true,
      warranty: false,
      product_categories: { create: { id_category: catHome.id_category } }
    }
  });

  // 8. ASIGNAR PRODUCTO AL VENDEDOR
  await prisma.seller_products.create({
    data: {
      id_seller: seller.id_user,
      id_product: product1.id_product,
      quantity: 2 // Le damos 2 iPhones para vender
    }
  });

  // 9. VENTA (Simulaci√≥n)
  // El vendedor vende 1 iPhone.
  // C√°lculo: $900 USD * 520 Tasa = 468,000 CUP
  const sale = await prisma.sales.create({
    data: {
      id_seller: seller.id_user,
      sale_date: new Date(),
      exchange_rate: 520.00,
      total_cup: 468000.00, // $900 USD
      buyer_phone: "5355555555",
      payment_method: "cash",
      notes: "Venta de prueba seed",
      sale_products: {
        create: {
          id_product: product1.id_product,
          quantity: 1
        }
      }
    }
  });

  // Actualizar stock tras venta (manual en seed)
  await prisma.products.update({
    where: { id_product: product1.id_product },
    data: { stock: 4 } // Eran 5, vendi√≥ 1
  });
  console.log('üí∞ Venta registrada.');

  // 10. DEVOLUCI√ìN (Simulaci√≥n)
  // Alguien devuelve una AirFryer de una venta anterior hipot√©tica
  // Primero creamos la venta de la AirFryer
  const saleReturn = await prisma.sales.create({
    data: {
      id_seller: seller.id_user,
      sale_date: new Date(),
      exchange_rate: 520.00,
      total_cup: 62400.00, // $120 * 520
      buyer_phone: "5359999999",
      payment_method: "transfer",
      sale_products: { create: { id_product: product2.id_product, quantity: 1 } }
    }
  });

  // Ahora registramos la devoluci√≥n
  await prisma.returns.create({
    data: {
      id_sale: saleReturn.id_sale,
      id_product: product2.id_product,
      quantity: 1,
      loss_usd: 10.00, // Se perdi√≥ $10 en transporte/mensajer√≠a
      reason: "Producto con golpe de f√°brica", // Usando el nuevo campo
      return_date: new Date()
    }
  });
  console.log('üîÑ Devoluci√≥n registrada.');

  console.log('‚úÖ SEED COMPLETADO EXITOSAMENTE.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma\migrations\migration_lock.toml
============================================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "mysql"
.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\prisma\migrations\20260109141221_init\migration.sql
============================================
-- CreateTable
CREATE TABLE `system_configuration` (
    `id_config` INTEGER NOT NULL AUTO_INCREMENT,
    `company_name` VARCHAR(191) NOT NULL,
    `logo_url` VARCHAR(191) NULL,
    `description` VARCHAR(191) NULL,
    `seller_commission_percentage` DOUBLE NOT NULL,
    `weekly_report_day` INTEGER NULL,
    `weekly_report_time` DATETIME(3) NULL,
    `monthly_report_day` INTEGER NULL,
    `monthly_report_time` DATETIME(3) NULL,
    `annual_report_day` INTEGER NULL,
    `annual_report_time` DATETIME(3) NULL,
    `default_exchange_rate` DOUBLE NOT NULL,
    `telegram_bot_token` VARCHAR(191) NOT NULL,
    `created_at` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `active` BOOLEAN NOT NULL DEFAULT true,

    PRIMARY KEY (`id_config`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `users` (
    `id_user` INTEGER NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(191) NOT NULL,
    `email` VARCHAR(191) NULL,
    `photo_url` VARCHAR(191) NULL,
    `password_hash` VARCHAR(191) NOT NULL,
    `telegram_chat_id` VARCHAR(191) NULL,
    `role` ENUM('admin', 'seller', 'storekeeper') NOT NULL,
    `created_at` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `active` BOOLEAN NOT NULL DEFAULT true,

    UNIQUE INDEX `users_email_key`(`email`),
    PRIMARY KEY (`id_user`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `products` (
    `id_product` INTEGER NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(191) NOT NULL,
    `description` VARCHAR(191) NULL,
    `purchase_price` DOUBLE NOT NULL,
    `sale_price` DOUBLE NOT NULL,
    `stock` INTEGER NOT NULL DEFAULT 0,
    `sku` VARCHAR(191) NULL,
    `supplier_name` VARCHAR(191) NULL,
    `date_added` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `active` BOOLEAN NOT NULL DEFAULT true,
    `photo_url` VARCHAR(191) NULL,
    `warranty` BOOLEAN NOT NULL DEFAULT false,

    PRIMARY KEY (`id_product`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `categories` (
    `id_category` INTEGER NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(191) NOT NULL,
    `active` BOOLEAN NOT NULL DEFAULT true,

    PRIMARY KEY (`id_category`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `product_categories` (
    `id_product_category` INTEGER NOT NULL AUTO_INCREMENT,
    `id_product` INTEGER NOT NULL,
    `id_category` INTEGER NOT NULL,

    PRIMARY KEY (`id_product_category`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `sales` (
    `id_sale` INTEGER NOT NULL AUTO_INCREMENT,
    `sale_date` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `exchange_rate` DOUBLE NOT NULL,
    `total_cup` DOUBLE NOT NULL,
    `buyer_phone` VARCHAR(191) NOT NULL,
    `notes` VARCHAR(191) NULL,
    `payment_method` ENUM('cash', 'transfer') NOT NULL,
    `id_seller` INTEGER NOT NULL,

    PRIMARY KEY (`id_sale`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `sale_products` (
    `id_sale_product` INTEGER NOT NULL AUTO_INCREMENT,
    `id_sale` INTEGER NOT NULL,
    `id_product` INTEGER NOT NULL,
    `quantity` INTEGER NOT NULL,

    PRIMARY KEY (`id_sale_product`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `returns` (
    `id_return` INTEGER NOT NULL AUTO_INCREMENT,
    `id_sale` INTEGER NOT NULL,
    `id_product` INTEGER NOT NULL,
    `quantity` INTEGER NOT NULL,
    `return_date` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `loss_usd` DOUBLE NOT NULL,
    `notes` VARCHAR(191) NULL,

    PRIMARY KEY (`id_return`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `shipments` (
    `id_shipment` INTEGER NOT NULL AUTO_INCREMENT,
    `agency_name` VARCHAR(191) NOT NULL,
    `shipment_date` DATETIME(3) NOT NULL,
    `shipping_cost_usd` DOUBLE NOT NULL,
    `customs_fee_cup` DOUBLE NOT NULL,
    `exchange_rate` DOUBLE NOT NULL,
    `notes` VARCHAR(191) NULL,

    PRIMARY KEY (`id_shipment`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `seller_products` (
    `id_seller_product` INTEGER NOT NULL AUTO_INCREMENT,
    `id_seller` INTEGER NOT NULL,
    `id_product` INTEGER NOT NULL,
    `quantity` INTEGER NOT NULL DEFAULT 0,
    `assigned_at` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),

    PRIMARY KEY (`id_seller_product`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `product_categories` ADD CONSTRAINT `product_categories_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products`(`id_product`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `product_categories` ADD CONSTRAINT `product_categories_id_category_fkey` FOREIGN KEY (`id_category`) REFERENCES `categories`(`id_category`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `sales` ADD CONSTRAINT `sales_id_seller_fkey` FOREIGN KEY (`id_seller`) REFERENCES `users`(`id_user`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `sale_products` ADD CONSTRAINT `sale_products_id_sale_fkey` FOREIGN KEY (`id_sale`) REFERENCES `sales`(`id_sale`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `sale_products` ADD CONSTRAINT `sale_products_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products`(`id_product`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `returns` ADD CONSTRAINT `returns_id_sale_fkey` FOREIGN KEY (`id_sale`) REFERENCES `sales`(`id_sale`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `returns` ADD CONSTRAINT `returns_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products`(`id_product`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `seller_products` ADD CONSTRAINT `seller_products_id_seller_fkey` FOREIGN KEY (`id_seller`) REFERENCES `users`(`id_user`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `seller_products` ADD CONSTRAINT `seller_products_id_product_fkey` FOREIGN KEY (`id_product`) REFERENCES `products`(`id_product`) ON DELETE RESTRICT ON UPDATE CASCADE;
.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\auth.js
============================================
// src/auth.js
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';

const APP_SECRET = process.env.JWT_SECRET || "fallback_secret_dev";

// 1. Encriptar contrase√±a (para cuando creas usuario)
export const hashPassword = (password) => {
  return bcrypt.hash(password, 10);
};

// 2. Comparar contrase√±a (para el login)
export const comparePassword = (password, hash) => {
  return bcrypt.compare(password, hash);
};

// 3. Crear Token (darle la llave al usuario)
export const createToken = (user) => {
  return jwt.sign({ userId: user.id_user, role: user.role }, APP_SECRET, {
    expiresIn: '7d', // El token dura 7 d√≠as
  });
};

// 4. Verificar Token (revisar la llave en cada petici√≥n)
export const getUserFromToken = (token) => {
  if (token) {
    try {
      // El token suele venir como "Bearer eyJhbGci..."
      const tokenValue = token.replace('Bearer ', '');
      const verified = jwt.verify(tokenValue, APP_SECRET);
      return verified; // Devuelve { userId: 1, role: 'admin' }
    } catch (error) {
      return null;
    }
  }
  return null;
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\index.js
============================================
import express from "express";
import { ApolloServer } from "apollo-server-express";
import { typeDefs } from "./schema.js";
import { resolvers } from "./resolvers.js";
import { getUserFromToken } from "./auth.js";
import { initTelegramBot } from "./telegram.js"; 
import { initScheduler } from "./services/scheduler.js"; 
import dotenv from 'dotenv';
import multer from 'multer';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import cors from 'cors';
import { v2 as cloudinary } from 'cloudinary'; 
import { spawn } from 'child_process';
import { URL } from 'url'; 

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ---------------------------------------------------------
// 1Ô∏è‚É£ CONFIGURACI√ìN DE CLOUDINARY (DIRECTA PARA EVITAR ERRORES)
// ---------------------------------------------------------
cloudinary.config({
  cloud_name: 'ddnqbgqfn',
  api_key: '714472522733682',
  api_secret: 'S1cBDX5f9_Ox5ncFVl4slpgKTZk'
});



// Debug para ver si carg√≥ (aparecer√° en la terminal negra)
console.log("‚úÖ Configuraci√≥n de Cloudinary cargada manualmente.");

// Crear carpeta uploads temporal si no existe para evitar error 500 por carpeta faltante
const uploadDir = path.join(process.cwd(), 'uploads');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
  console.log("üìÅ Carpeta 'uploads/' creada.");
}

const app = express();

// üî• CORS: Siempre al principio
app.use(cors()); 

// ---------------------------------------------------------
// 2Ô∏è‚É£ CONFIGURACI√ìN MULTER (Almacenamiento Temporal)
// ---------------------------------------------------------
const storage = multer.diskStorage({
  destination: (req, file, cb) => { 
    cb(null, 'uploads/'); 
  },
  filename: (req, file, cb) => {
    // Limpiamos el nombre del archivo para evitar caracteres raros
    const cleanName = file.originalname.replace(/[^a-zA-Z0-9.]/g, "_");
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, 'img-' + uniqueSuffix + '-' + cleanName);
  }
});

const fileFilter = (req, file, cb) => {
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('‚õî Solo se permiten archivos de imagen.'), false);
  }
};

const upload = multer({ storage, fileFilter });

// ---------------------------------------------------------
// 3Ô∏è‚É£ ENDPOINT DE SUBIDA (Debuggeado)
// ---------------------------------------------------------
app.post('/api/upload', upload.single('file'), async (req, res) => {
  console.log("üì• Recibiendo petici√≥n de subida...");

  try {
    if (!req.file) {
      console.error("‚ùå Error: No lleg√≥ ning√∫n archivo (req.file es undefined)");
      return res.status(400).json({ error: 'No se subi√≥ ning√∫n archivo.' });
    }

    console.log(`üìÅ Archivo recibido localmente: ${req.file.path}`);
    console.log("‚òÅÔ∏è  Intentando subir a Cloudinary...");


    // ‚ö†Ô∏è PARCHE DE HORA: Sumamos 2 horas (7200 segundos) para corregir el retraso de tu PC
    const timestampFuturo = Math.round((new Date().getTime() / 1000)) + 7200;

    const result = await cloudinary.uploader.upload(req.file.path, {
      folder: "habana_express_store", 
      use_filename: true,
      unique_filename: false,
      timestamp: timestampFuturo // <--- Forzamos la hora
    });

    // // Subir a Cloudinary para VPS
    // const result = await cloudinary.uploader.upload(req.file.path, {
    //   folder: "habana_express_store", 
    //   use_filename: true,
    //   unique_filename: false,
    // });

    console.log("‚úÖ √âxito en Cloudinary! URL:", result.secure_url);

    // Eliminar archivo local
    try {
      fs.unlinkSync(req.file.path);
    } catch (e) {
      console.warn("‚ö†Ô∏è No se pudo borrar el archivo temporal (no es cr√≠tico):", e.message);
    }

    // Responder al Frontend
    res.status(200).json({ 
      message: 'Imagen subida exitosamente.', 
      url: result.secure_url 
    });

  } catch (error) {
    console.error("‚ùå ERROR CR√çTICO EN /api/upload:", error);
    
    // Intentar limpieza
    if (req.file && fs.existsSync(req.file.path)) {
      try { fs.unlinkSync(req.file.path); } catch(e) {}
    }

    // Devolver el error real al frontend para que lo veas en la consola del navegador
    res.status(500).json({ 
      error: 'Error interno del servidor', 
      details: error.message 
    });
  }
});


// ---------------------------------------------------------
// üÜï ENDPOINT DE BACKUP (Base de Datos)
// ---------------------------------------------------------
app.get('/api/backup', async (req, res) => {
  console.log("üíæ Iniciando proceso de respaldo...");

  // 1. Seguridad: Verificar Token
  const token = req.headers.authorization || '';
  const user = getUserFromToken(token);

  if (!user || user.role !== 'admin') {
    return res.status(403).send('‚õî Acceso denegado. Solo administradores.');
  }

  // 2. Obtener credenciales desde DATABASE_URL (.env)
  // Formato: mysql://USER:PASSWORD@HOST:PORT/DB_NAME
  const dbUrl = process.env.DATABASE_URL;
  if (!dbUrl) return res.status(500).send('Error: DATABASE_URL no configurada.');

  try {
    const parsedUrl = new URL(dbUrl);
    const username = parsedUrl.username;
    const password = parsedUrl.password;
    const host = parsedUrl.hostname;
    const port = parsedUrl.port || '3306';
    const database = parsedUrl.pathname.substring(1); // Quita el '/' inicial

    // 3. Configurar Headers para descarga
    const date = new Date().toISOString().split('T')[0];
    const filename = `backup_habana_express_${date}.sql`;

    res.setHeader('Content-Type', 'application/octet-stream');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);

    // 4. Ejecutar mysqldump
    // NOTA: 'mysqldump' debe estar instalado en el sistema y accesible en el PATH
    const dumpProcess = spawn('mysqldump', [
      '-h', host,
      '-P', port,
      '-u', username,
      `-p${password}`, // Sin espacio despu√©s de -p
      '--single-transaction', // Para no bloquear la DB mientras copia
      '--quick',
      '--lock-tables=false',
      database
    ]);

    // 5. Enviar el resultado directamente al navegador (Streaming)
    dumpProcess.stdout.pipe(res);

    // Manejo de errores del proceso
    dumpProcess.stderr.on('data', (data) => {
      console.error(`‚ùå Mysqldump Error: ${data}`);
    });

    dumpProcess.on('close', (code) => {
      if (code === 0) {
        console.log('‚úÖ Respaldo completado y enviado.');
      } else {
        console.error(`‚ö†Ô∏è Proceso de respaldo termin√≥ con c√≥digo ${code}`);
      }
    });

  } catch (error) {
    console.error("Critical Backup Error:", error);
    if (!res.headersSent) res.status(500).send('Error interno generando backup.');
  }
});


// ---------------------------------------------------------
// 4Ô∏è‚É£ INICIO DEL SERVIDOR
// ---------------------------------------------------------
async function startServer() {
  
  // Init Scheduler
  initScheduler();

  // Apollo Server
  const server = new ApolloServer({
    typeDefs,
    resolvers,
    context: ({ req }) => {
      const token = req.headers.authorization || '';
      const user = getUserFromToken(token);
      return { user };
    },
  });

  await server.start();
  server.applyMiddleware({ app });

  const PORT = process.env.PORT || 4000;
  app.listen({ port: PORT }, () => {
    console.log(`üöÄ Server ready at http://localhost:${PORT}${server.graphqlPath}`);
    console.log(`‚òÅÔ∏è  Cloudinary Upload ready at http://localhost:${PORT}/api/upload`);
    
    initTelegramBot();
  });
}

startServer();.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\resolvers.js
============================================
// src/resolvers.js
import { PrismaClient } from '@prisma/client';
import { hashPassword, comparePassword, createToken } from './auth.js';
import { getMonthlyReport, getAnnualReport, calculateTopSellers } from './services/finance.js';
import { notifySale, notifyReturn, notifyStockDepletion } from './telegram.js';
import { executeDailyUpdate } from './services/scheduler.js'; 

const prisma = new PrismaClient();

/* üõ°Ô∏è --- SECURITY GUARDS --- üõ°Ô∏è */

const requireAuth = (user) => {
  if (!user) throw new Error('‚õî Autorizaci√≥n requerida');
};

// 1. Admin Only
const requireAdmin = (user) => {
  requireAuth(user);
  if (user.role !== 'admin') {
    throw new Error('‚õî Acceso denegado: se requiere rol de Admin');
  }
};

// 2. Storekeeper or Admin (Admin is allowed)
const requireStorekeeper = (user) => {
  requireAuth(user);
  if (user.role === 'admin') return; 
  if (user.role !== 'storekeeper') {
    throw new Error('‚õî Acceso denegado: se requiere rol de Storekeeper');
  }
};

// 3. Seller or Admin (Admin is allowed)
const requireSeller = (user) => {
  requireAuth(user);
  if (user.role === 'admin') return; 
  if (user.role !== 'seller') {
    throw new Error('‚õî Acceso denegado: se requiere rol de Seller ');
  }
};

/* üöÄ --- RESOLVERS --- üöÄ */

export const resolvers = {
  Query: {
    // --- USERS ---
    users: (_, __, { user }) => {
      requireStorekeeper(user); 
      return prisma.users.findMany({ include: { seller_products: true, sales: true } });
    },
    user: (_, { id_user }, { user }) => {
      requireAdmin(user);
      return prisma.users.findUnique({ where: { id_user }, include: { seller_products: true, sales: true } });
    },
    me: (_, __, { user }) => {
      requireAuth(user);
      return prisma.users.findUnique({ 
        where: { id_user: user.userId }
      });
    },

    // --- PRODUCTS ---
    products: (_, { active }, { user }) => {
      requireAuth(user);
      const isActiveFilter = active !== undefined ? active : true;
      return prisma.products.findMany({ 
        where: { active: isActiveFilter }, 
        include: { 
            product_categories: { include: { category: true } }, 
            sale_products: true, 
            seller_products: true 
        },
        orderBy: { date_added: 'desc' }
      });
    },
    product: (_, { id_product }, { user }) => {
      requireAuth(user);
      return prisma.products.findUnique({ 
          where: { id_product }, 
          include: { 
              product_categories: { include: { category: true } }, 
              seller_products: true 
          } 
      });
    },

    // --- CATEGORIES ---
    categories: (_, __, { user }) => {
      requireAuth(user);
      return prisma.categories.findMany({ 
        where: { active: true },
        include: { product_categories: true } 
      });
    },

    // --- SALES & RETURNS ---
    sales: (_, __, { user }) => {
      requireStorekeeper(user); 
      return prisma.sales.findMany({ 
        include: { sale_products: { include: { product: true } }, seller: true },
        orderBy: { sale_date: 'desc' }
      });
    },
    
    sale: (_, { id_sale }, { user }) => {
      requireAuth(user); 
      return prisma.sales.findUnique({ where: { id_sale }, include: { sale_products: { include: { product: true } }, seller: true } });
    },
    returns: (_, __, { user }) => {
      requireStorekeeper(user); 
      return prisma.returns.findMany({ 
        include: { product: true, sale: true },
        orderBy: { return_date: 'desc' }
      });
    },

    // --- LOGISTICS & INVENTORY ---
    shipments: (_, __, { user }) => {
      requireStorekeeper(user);
      return prisma.shipments.findMany({ orderBy: { shipment_date: 'desc' } });
    },
    
    sellerProducts: (_, { sellerId }, { user }) => {
      requireAuth(user);
      let targetId = (user.role === 'admin' || user.role === 'storekeeper') ? sellerId : user.id_user;
      
      return prisma.seller_products.findMany({
        where: { id_seller: targetId },
        include: { seller: true, product: true },
      });
    },

    // --- DASHBOARD & REPORTS ---
   dashboardStats: async (_, __, { user }) => {
      requireAuth(user);
      
      const config = await prisma.system_configuration.findFirst();
      let activeProductsCount = 0;
      let totalItemsSold = 0;

      // L√ìGICA DIFERENCIADA POR ROL
      if (user.role === 'seller') {
        // --- CASO VENDEDOR: SOLO SU MUNDO ---
        
        // 1. Stock: Cantidad de SKUs (productos distintos) que tiene asignados y con cantidad > 0
        activeProductsCount = await prisma.seller_products.count({
            where: { 
                id_seller: user.userId, // Usamos userId que viene del token (en el context es user.userId o user.id_user seg√∫n tu auth.js, revisa eso. En tu c√≥digo anterior era user.userId)
                quantity: { gt: 0 }     // Solo lo que tiene existencia real
            }
        });

        // 2. Ventas: Suma de cantidades vendidas SOLO por √©l
        const soldAggregation = await prisma.sale_products.aggregate({
            _sum: { quantity: true },
            where: { 
                sale: { 
                    id_seller: user.userId, // Solo sus ventas
                    status: 'COMPLETED'     // Solo ventas confirmadas
                } 
            }
        });
        totalItemsSold = soldAggregation._sum.quantity || 0;

      } else {
        // --- CASO ADMIN / STOREKEEPER: TODO EL SISTEMA ---
        
        // 1. Stock: Total de productos activos en el almac√©n global
        activeProductsCount = await prisma.products.count({
            where: { active: true }
        });

        // 2. Ventas: Suma de TODAS las ventas globales
        const soldAggregation = await prisma.sale_products.aggregate({
            _sum: { quantity: true },
            where: { sale: { status: 'COMPLETED' } }
        });
        totalItemsSold = soldAggregation._sum.quantity || 0;
      }

      return {
        exchangeRate: config?.default_exchange_rate || 0,
        activeProductsCount,
        totalItemsSold
      };
    },
    
    systemConfiguration: (_, __, { user }) => {
      requireAuth(user); 
      return prisma.system_configuration.findMany();
    },
    monthlyReport: async (_, __, { user }) => {
      requireAdmin(user);
      return await getMonthlyReport();
    },
    annualReport: async (_, __, { user }) => {
      requireAdmin(user);
      return await getAnnualReport();
    },
    topSellers: async (_, { period }, { user }) => {
      requireAuth(user);
      return await calculateTopSellers(period);
    },
  },

  Mutation: {
    // --- AUTH ---
    login: async (_, { phone, password }) => {
      const user = await prisma.users.findUnique({ where: { phone } });
      if (!user) throw new Error('Usuario no encontrado');
      
      const valid = await comparePassword(password, user.password_hash);
      if (!valid) throw new Error('Contrase√±a incorrecta');
      
      if (!user.active) throw new Error('La cuenta est√° desactivada');
      
      return { token: createToken(user), user };
    },

    createUser: async (_, { input }, { user }) => {
      requireAdmin(user);
      const hashedPassword = await hashPassword(input.password_hash);
      return prisma.users.create({ data: { ...input, password_hash: hashedPassword } });
    },

    updateUser: async (_, { id_user, input }, { user }) => {
      requireAuth(user);
      if (user.role !== 'admin' && user.userId !== id_user) {
        throw new Error("‚õî Prohibido: solo puedes editar tu propio perfil");
      }

      const dataToUpdate = { ...input };
      if (user.role !== 'admin' && dataToUpdate.role) delete dataToUpdate.role; 
      if (dataToUpdate.password) {
        dataToUpdate.password_hash = await hashPassword(dataToUpdate.password);
        delete dataToUpdate.password; 
      } else {
        delete dataToUpdate.password;
      }

      return prisma.users.update({ where: { id_user }, data: dataToUpdate });
    },

    deleteUser: async (_, { id_user }, { user }) => {
      requireAdmin(user);
      return prisma.users.update({ where: { id_user }, data: { active: false } });
    },

    // --- CONFIGURATION ---
    updateSystemConfiguration: async (_, { id_config, input }, { user }) => {
      requireAdmin(user);
      return prisma.system_configuration.update({ where: { id_config }, data: input });
    },
    
    triggerPriceSync: async (_, __, { user }) => {
      try {
        await executeDailyUpdate(); 
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    },

    // --- CATEGORIES ---
    createCategory: (_, { name }, { user }) => {
       requireStorekeeper(user);
       return prisma.categories.create({ data: { name } });
    },
    updateCategory: (_, { id_category, name }, { user }) => {
       requireStorekeeper(user);
       return prisma.categories.update({ where: { id_category }, data: { name } });
    },
    deleteCategory: async (_, { id_category }, { user }) => {
      requireStorekeeper(user);
      return prisma.categories.update({ where: { id_category }, data: { active: false } });
    },

    // --- PRODUCTS ---
    createProduct: (_, { input }, { user }) => {
      requireStorekeeper(user); 
      const { categoryIds, ...productData } = input;
      
      let finalSku = productData.sku;
      if (!finalSku) {
         const year = new Date().getFullYear();
         const randomSuffix = Math.random().toString(36).substring(2, 6).toUpperCase();
         finalSku = `HEX-${year}-${randomSuffix}`;
      }

      const isActive = productData.stock > 0 ? true : (productData.active ?? false);

      return prisma.products.create({ 
          data: { 
              ...productData, 
              sku: finalSku, 
              active: isActive,
              product_categories: {
                create: categoryIds ? categoryIds.map(id => ({ category: { connect: { id_category: id } } })) : []
              }
          },
          include: { product_categories: { include: { category: true } } }
      });
    },

    updateProduct: async (_, { id_product, input }, { user }) => {
      requireStorekeeper(user); 
      const { categoryIds, ...dataToUpdate } = input;

      if (dataToUpdate.stock !== undefined) {
        if (dataToUpdate.stock > 0) dataToUpdate.active = true;
        else if (dataToUpdate.stock === 0) dataToUpdate.active = false;
      }

      return prisma.products.update({
        where: { id_product },
        data: {
            ...dataToUpdate,
            ...(categoryIds && {
                product_categories: {
                    deleteMany: {}, 
                    create: categoryIds.map(id => ({ category: { connect: { id_category: id } } }))
                }
            })
        },
        include: { product_categories: { include: { category: true } } }
      });
    },

    deleteProduct: async (_, { id_product }, { user }) => {
      requireStorekeeper(user); 
      return await prisma.products.delete({ where: { id_product } });
    },

    // --- INVENTORY ASSIGNMENT ---
    assignProductToSeller: async (_, { sellerId, productId, quantity }, { user }) => {
      requireStorekeeper(user); 
      
      const product = await prisma.products.findUnique({ where: { id_product: productId } });
      if (!product) throw new Error("Producto no encontrado");
      
      if (quantity > product.stock) {
          throw new Error(`‚õî Stock global insuficiente. Disponible: ${product.stock}`);
      }

      const existing = await prisma.seller_products.findFirst({ where: { id_seller: sellerId, id_product: productId } });
      
      if (existing) {
        return prisma.seller_products.update({
          where: { id_seller_product: existing.id_seller_product },
          data: { quantity: { increment: quantity } },
          include: { seller: true, product: true }
        });
      } else {
        return prisma.seller_products.create({
          data: { id_seller: sellerId, id_product: productId, quantity },
          include: { seller: true, product: true },
        });
      }
    },

    returnProductFromSeller: async (_, { sellerId, productId, quantity }, { user }) => {
      requireStorekeeper(user);
      const assignment = await prisma.seller_products.findFirst({ where: { id_seller: sellerId, id_product: productId } });
      if (!assignment || assignment.quantity < quantity) {
        throw new Error("‚õî El vendedor no tiene esa cantidad.");
      }

      if (assignment.quantity === quantity) {
         await prisma.seller_products.delete({ where: { id_seller_product: assignment.id_seller_product } });
         return { ...assignment, quantity: 0 }; 
      } else {
         return prisma.seller_products.update({
            where: { id_seller_product: assignment.id_seller_product },
            data: { quantity: { decrement: quantity } },
            include: { product: true }
         });
      }
    },

    // --- SALES ---
    createSale: async (_, { sellerId, exchange_rate, total_cup, buyer_phone, payment_method, notes, items }, { user }) => {
      // Seguridad: Un vendedor solo vende lo suyo, Admin vende por cualquiera
      if (user.role !== 'admin' && parseInt(user.userId) !== sellerId) {
           throw new Error('‚õî No puedes registrar ventas de otro usuario.');
      }

      // Validar Stock Asignado
      for (const item of items) {
        const product = await prisma.products.findUnique({ where: { id_product: item.productId } });
        if (!product) throw new Error(`Producto ${item.productId} no encontrado`);

        const assignment = await prisma.seller_products.findFirst({
            where: { id_seller: sellerId, id_product: item.productId }
        });

        if (!assignment || assignment.quantity < item.quantity) {
            throw new Error(`‚õî Stock insuficiente de: ${product.name}.`);
        }
      }

      // Crear Venta (Default Status: COMPLETED)
      const sale = await prisma.sales.create({
        data: { 
            id_seller: sellerId, 
            exchange_rate, 
            total_cup, 
            buyer_phone, 
            payment_method, 
            notes,
            status: 'COMPLETED'
        },
      });

      // Mover Inventario
      for (const { productId, quantity } of items) {
        await prisma.sale_products.create({
          data: { id_sale: sale.id_sale, id_product: productId, quantity },
        });

        // A. Restar Stock Global
        const updatedProduct = await prisma.products.update({
          where: { id_product: productId },
          data: { stock: { decrement: quantity } },
        });
        
        if (updatedProduct.stock <= 0) {
            await prisma.products.update({ where: { id_product: productId }, data: { active: false } });
         
            try { await notifyStockDepletion(updatedProduct); } catch (e) { console.error(e); }
          }

        // B. Restar Asignaci√≥n del Vendedor
        const assignment = await prisma.seller_products.findFirst({ where: { id_seller: sellerId, id_product: productId } });
        if (assignment.quantity === quantity) {
            await prisma.seller_products.delete({ where: { id_seller_product: assignment.id_seller_product } });
        } else {
            await prisma.seller_products.update({
                where: { id_seller_product: assignment.id_seller_product },
                data: { quantity: { decrement: quantity } }
            });
        }
      }

      const saleResult = await prisma.sales.findUnique({
        where: { id_sale: sale.id_sale },
        include: { sale_products: { include: { product: true } }, seller: true },
      });

      try { await notifySale(saleResult); } catch (e) { console.error(e); }
      return saleResult;
    },

    updateSale: async (_, { id_sale, input }, { user }) => {
      requireAdmin(user);
      return prisma.sales.update({
        where: { id_sale },
        data: input,
        include: { seller: true }
      });
    },

    // üî¥ ANULAR VENTA (CANCEL) - Reemplaza l√≥gica de borrado f√≠sico
    cancelSale: async (_, { id_sale }, { user }) => {
      requireAdmin(user);

      const sale = await prisma.sales.findUnique({
        where: { id_sale },
        include: { sale_products: true }
      });

      if (!sale) throw new Error("Venta no encontrada");
      if (sale.status === 'CANCELLED') throw new Error("La venta ya est√° anulada.");

      // Transacci√≥n: Cambiar estado y devolver stocks
      return await prisma.$transaction(async (tx) => {
          // 1. Marcar como CANCELLED
          const updatedSale = await tx.sales.update({
              where: { id_sale },
              data: { status: 'CANCELLED' }
          });

          // 2. Devolver items
          for (const item of sale.sale_products) {
              // A. Devolver al Global y Reactivar
              await tx.products.update({
                  where: { id_product: item.id_product },
                  data: { 
                      stock: { increment: item.quantity },
                      active: true 
                  }
              });

              // B. Devolver al Vendedor (Upsert manual para seguridad)
              const existingAssignment = await tx.seller_products.findFirst({
                  where: { id_seller: sale.id_seller, id_product: item.id_product }
              });

              if (existingAssignment) {
                  await tx.seller_products.update({
                      where: { id_seller_product: existingAssignment.id_seller_product },
                      data: { quantity: { increment: item.quantity } }
                  });
              } else {
                  await tx.seller_products.create({
                      data: {
                          id_seller: sale.id_seller,
                          id_product: item.id_product,
                          quantity: item.quantity
                      }
                  });
              }
          }
          return updatedSale;
      });
    },

    // --- RETURNS (DEVOLUCIONES) ---
    createReturn: async (_, { saleId, productId, quantity, reason, returnToStock }, { user }) => {
       // Solo Admin o Storekeeper
       if (user.role !== 'admin' && user.role !== 'storekeeper') {
          throw new Error("‚õî Access Denied.");
       }

       // 1. Validar Venta
       const sale = await prisma.sales.findUnique({ where: { id_sale: saleId } });
       if (!sale) throw new Error("Venta no encontrada");
       if (sale.status === 'CANCELLED') throw new Error("No se pueden hacer devoluciones de ventas anuladas.");

       // 2. Validar Item en la Venta
       const soldItem = await prisma.sale_products.findFirst({
          where: { id_sale: saleId, id_product: productId }
       });
       if (!soldItem || soldItem.quantity < quantity) {
          throw new Error("Cantidad inv√°lida para esta venta.");
       }

       // 3. Obtener info del producto para costo
       const productInfo = await prisma.products.findUnique({ 
           where: { id_product: productId } 
       });

       let calculatedLoss = 0;
       if (!returnToStock) {
           calculatedLoss = Number(productInfo.purchase_price) * quantity;
       }

       // 4. Transacci√≥n en Base de Datos
       const resultReturn = await prisma.$transaction(async (tx) => {
           // A. Crear Registro Devoluci√≥n
           const ret = await tx.returns.create({
             data: { 
                 id_sale: saleId, 
                 id_product: productId, 
                 quantity, 
                 loss_usd: calculatedLoss,
                 reason 
             },
             // üëá CAMBIO IMPORTANTE: Incluimos al Vendedor (seller) dentro de la venta (sale)
             include: { 
                 product: true, 
                 sale: { 
                     include: { seller: true } 
                 } 
             }
           });

           // B. Si returnToStock es TRUE, devolvemos al Global
           if (returnToStock) {
               await tx.products.update({
                 where: { id_product: productId },
                 data: { 
                     stock: { increment: quantity },
                     active: true 
                 }
               });
           }

           return ret;
       });

       // üëá NUEVO: Llamamos a la notificaci√≥n pasando el booleano returnToStock
       try { 
           await notifyReturn(resultReturn, returnToStock); 
       } catch (e) { 
           console.error("Error enviando notificaci√≥n Telegram:", e); 
       }

       return resultReturn;
    },

    // --- SHIPMENTS ---
    createShipment: (_, args, { user }) => { 
      requireAdmin(user); 
      return prisma.shipments.create({ data: args }); 
    },

    updateShipment: (_, { id_shipment, input }, { user }) => {
      requireAdmin(user);
      
      const dataToUpdate = {
        ...input,
        shipment_date: input.shipment_date ? new Date(input.shipment_date) : undefined,
        shipping_cost_usd: input.shipping_cost_usd ? parseFloat(input.shipping_cost_usd) : undefined,
        merchandise_cost_usd: input.merchandise_cost_usd ? parseFloat(input.merchandise_cost_usd) : undefined,
        customs_fee_cup: input.customs_fee_cup ? parseFloat(input.customs_fee_cup) : undefined,
        exchange_rate: input.exchange_rate ? parseFloat(input.exchange_rate) : undefined,
      };

      // Limpieza de undefined
      Object.keys(dataToUpdate).forEach(key => dataToUpdate[key] === undefined && delete dataToUpdate[key]);

      return prisma.shipments.update({ where: { id_shipment }, data: dataToUpdate });
    },

    deleteShipment: async (_, { id_shipment }, { user }) => { 
      requireAdmin(user); 
      return prisma.shipments.delete({ where: { id_shipment } }); 
    },
  },

  // Field Resolvers
  SaleProduct: { 
    product: (parent) => parent.product || prisma.products.findUnique({ where: { id_product: parent.id_product } }) 
  },
  Return: { 
    product: (parent) => parent.product || prisma.products.findUnique({ where: { id_product: parent.id_product } }), 
    sale: (parent) => parent.sale || prisma.sales.findUnique({ where: { id_sale: parent.id_sale } }) 
  },
  SellerProduct: { 
    product: (parent) => parent.product || prisma.products.findUnique({ where: { id_product: parent.id_product } }), 
    seller: (parent) => parent.seller || prisma.users.findUnique({ where: { id_user: parent.id_seller } }) 
  }
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\schema.js
============================================
import { gql } from "apollo-server-express";

export const typeDefs = gql`
  enum Role {
    admin
    seller
    storekeeper
  }

  enum PaymentMethod {
    cash
    transfer
  }
  
  # ‚úÖ NUEVO ENUM AGREGADO
  enum SaleStatus {
    COMPLETED
    CANCELLED
  }

  type SystemConfiguration {
    id_config: Int!
    company_name: String!
    company_phone: String
    company_email: String
    logo_url: String
    description: String
    seller_commission_percentage: Float!
    monthly_report_day: Int
    monthly_report_time: String
    annual_report_day: Int
    annual_report_time: String
    exchange_rate_sync_time: String
    default_exchange_rate: Float!
    telegram_bot_token: String!
    created_at: String
    active: Boolean
  }

  type User {
    id_user: Int!
    name: String!
    phone: String!
    email: String
    photo_url: String
    telegram_chat_id: String
    role: Role!
    created_at: String
    active: Boolean
    sales: [Sale]
    seller_products: [SellerProduct]
  }

  type AuthPayload {
    token: String!
    user: User!
  }

  type Category {
    id_category: Int!
    name: String!
    active: Boolean
    product_categories: [ProductCategory]
  }

  type Product {
    id_product: Int!
    name: String!
    description: String
    purchase_price: Float!
    sale_price: Float!
    stock: Int
    sku: String
    supplier_name: String
    date_added: String
    active: Boolean
    photo_url: String
    warranty: Boolean
    product_categories: [ProductCategory]
    sale_products: [SaleProduct]
    returns: [Return]
    seller_products: [SellerProduct]
  }

  type ProductCategory {
    id_product_category: Int!
    product: Product!
    category: Category!
  }

  type Sale {
    id_sale: Int!
    sale_date: String
    exchange_rate: Float!
    total_cup: Float!
    buyer_phone: String!
    notes: String
    payment_method: PaymentMethod!
    status: SaleStatus!  # ‚úÖ CAMPO NUEVO
    seller: User!
    sale_products: [SaleProduct]
    returns: [Return]
  }

  type SaleProduct {
    id_sale_product: Int!
    quantity: Int!
    sale: Sale!
    product: Product!
    # Agregamos acceso directo a IDs por comodidad
    id_product: Int 
  }

  type Return {
    id_return: Int!
    quantity: Int!
    return_date: String
    loss_usd: Float!
    reason: String
    product: Product!
    sale: Sale!
  }

  type Shipment {
    id_shipment: Int!
    agency_name: String!
    shipment_date: String!
    shipping_cost_usd: Float!
    merchandise_cost_usd: Float! 
    customs_fee_cup: Float!
    exchange_rate: Float!
    notes: String
  }

  type DashboardStats {
    exchangeRate: Float!
    activeProductsCount: Int!
    totalItemsSold: Int!
  }

  type SellerProduct {
    id_seller_product: Int!
    quantity: Int!
    assigned_at: String
    seller: User!
    product: Product!
  }

  type TopSeller {
    id_user: Int!
    name: String!
    photo_url: String
    total_sales_usd: Float!
    items_sold: Int!
  }

  type MonthlyReport {
    month: Int!
    year: Int!
    income: Float!
    expenses: Float!
    netProfit: Float!
  }

  type AnnualReport {
    year: Int!
    totalNetProfit: Float!
    breakdown: [MonthlyBreakdown]
  }

  type MonthlyBreakdown {
    month: Int!
    investment: Float!      
    profit: Float!          
    roiPercentage: Float!   
  }

  # --- INPUTS ---

  input CreateUserInput {
    name: String!
    phone: String!
    email: String
    photo_url: String
    password_hash: String!
    telegram_chat_id: String
    role: Role!
  }

 input UpdateSaleInput {
    buyer_phone: String
    payment_method: PaymentMethod
    total_cup: Float
    exchange_rate: Float
    notes: String
  }
  
  input UpdateShipmentInput {
    agency_name: String
    shipment_date: String
    shipping_cost_usd: Float
    merchandise_cost_usd: Float
    customs_fee_cup: Float
    exchange_rate: Float
    notes: String
  }

  input UpdateUserInput {
    name: String
    phone: String
    email: String
    photo_url: String
    password: String      
    telegram_chat_id: String
    role: Role            
    active: Boolean
  }

  input CreateProductInput {
    name: String!
    description: String
    purchase_price: Float!
    sale_price: Float!
    stock: Int
    sku: String
    supplier_name: String
    photo_url: String
    warranty: Boolean
    active: Boolean
    categoryIds: [Int] 
  }

  input UpdateProductInput {
    name: String
    description: String
    purchase_price: Float
    sale_price: Float
    stock: Int
    sku: String
    supplier_name: String
    photo_url: String
    warranty: Boolean
    active: Boolean
    categoryIds: [Int]
  }

  input UpdateSystemConfigurationInput {
    company_name: String
    company_phone: String
    company_email: String
    logo_url: String
    description: String
    seller_commission_percentage: Float
    monthly_report_day: Int
    monthly_report_time: String
    annual_report_day: Int
    annual_report_time: String
    exchange_rate_sync_time: String
    default_exchange_rate: Float
    telegram_bot_token: String
    active: Boolean
  }

  input SaleItemInput {
    productId: Int!
    quantity: Int!
  }

  # --- QUERY & MUTATION ---

  type Query {
    me: User
    systemConfiguration: [SystemConfiguration]
    users: [User]
    user(id_user: Int!): User
    products(active: Boolean): [Product] 
    product(id_product: Int!): Product
    categories: [Category]
    sales: [Sale]
    sale(id_sale: Int!): Sale
    returns: [Return]
    shipments: [Shipment]
    sellerProducts(sellerId: Int!): [SellerProduct]
    
    monthlyReport: MonthlyReport
    annualReport: AnnualReport
    topSellers(period: String!): [TopSeller]
    dashboardStats: DashboardStats
  }

  type Mutation {
    login(phone: String!, password: String!): AuthPayload
    
    createUser(input: CreateUserInput!): User
    updateUser(id_user: Int!, input: UpdateUserInput!): User
    deleteUser(id_user: Int!): User

    createCategory(name: String!): Category 
    updateCategory(id_category: Int!, name: String!): Category
    deleteCategory(id_category: Int!): Category

    createProduct(input: CreateProductInput!): Product
    updateProduct(id_product: Int!, input: UpdateProductInput!): Product
    deleteProduct(id_product: Int!): Product
    
    assignProductToSeller(sellerId: Int!, productId: Int!, quantity: Int!): SellerProduct
    returnProductFromSeller(sellerId: Int!, productId: Int!, quantity: Int!): SellerProduct
    
    createSale(
      sellerId: Int!,
      exchange_rate: Float!,
      total_cup: Float!,
      buyer_phone: String!,
      payment_method: PaymentMethod!,
      notes: String,
      items: [SaleItemInput!]!
    ): Sale
    
    updateSale(id_sale: Int!, input: UpdateSaleInput!): Sale
    
    # ‚úÖ MUTACI√ìN CAMBIADA (Antes era deleteSale)
    cancelSale(id_sale: Int!): Sale
    
    # ‚úÖ MUTACI√ìN ACTUALIZADA (parametro returnToStock)
    createReturn(saleId: Int!, productId: Int!, quantity: Int!, reason: String, returnToStock: Boolean!): Return
    
    createShipment(
      agency_name: String!,
      shipment_date: String!,
      shipping_cost_usd: Float!,
      merchandise_cost_usd: Float!,
      customs_fee_cup: Float!,
      exchange_rate: Float!,
      notes: String
    ): Shipment

    updateShipment(id_shipment: Int!, input: UpdateShipmentInput!): Shipment 
    deleteShipment(id_shipment: Int!): Shipment
    
    updateSystemConfiguration(id_config: Int!, input: UpdateSystemConfigurationInput!): SystemConfiguration
    triggerPriceSync: Boolean
  }
`;.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\telegram.js
============================================
import { Telegraf } from 'telegraf';
import { PrismaClient } from '@prisma/client';
import { getMonthlyReport, getAnnualReport } from './services/finance.js';

const prisma = new PrismaClient();
let bot = null;

// --- üõ†Ô∏è FORMAT HELPERS (Estilo Ejecutivo) ---

const formatCurrency = (amount, currency = 'USD') => {
  const val = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: 2
  }).format(amount);
  return `<code>${val}</code>`; // Envoltorio code para Telegram
};

const formatNumber = (amount) => {
  return `<code>${new Intl.NumberFormat('en-US').format(amount)}</code>`;
};

const formatDate = (dateString) => {
  if (!dateString) return '<code>N/A</code>';
  const date = new Date(dateString);
  const str = date.toLocaleDateString('es-ES', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric'
  });
  return `<code>${str}</code>`;
};

const formatDateTime = (dateString) => {
    if (!dateString) return '<code>N/A</code>';
    const date = new Date(dateString);
    const str = date.toLocaleString('es-ES', {
      day: '2-digit', month: '2-digit', year: 'numeric',
      hour: '2-digit', minute: '2-digit', hour12: true
    });
    return `<code>${str}</code>`;
  };

const addDays = (date, days) => {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
};

const separator = "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";

const safeReply = async (chatId, message) => {
    if (!bot || !chatId) return; 
    try {
        await bot.telegram.sendMessage(chatId, message, { parse_mode: 'HTML' });
    } catch (error) {
        console.error(`‚ö†Ô∏è Telegram Send Error (Chat: ${chatId}):`, error.message);
    }
};

// --- üéÆ COMANDOS Y SEGURIDAD ---
const setupCommands = () => {
    
    // COMANDO START: L√≥gica inteligente seg√∫n rol
    bot.start(async (ctx) => {
        const chatId = ctx.chat.id.toString();
        
        // Buscamos qui√©n es este usuario en la DB
        const user = await prisma.users.findFirst({
            where: { telegram_chat_id: chatId }
        });

        // üÖ∞Ô∏è CASO ADMIN: Men√∫ completo
        if (user && user.role === 'admin') {
            const adminMsg = `
üëã <b>Hola Admin ${user.name}</b>

üõ†Ô∏è <b>PANEL DE CONTROL:</b>
üìä /monthly - Reporte Mensual
üìà /yearly - Reporte Anual
‚ùì /help - Ayuda
            `;
            return ctx.reply(adminMsg, { parse_mode: 'HTML' });
        }

        // üÖ±Ô∏è CASO VENDEDOR O DESCONOCIDO: Solo mostrar ID
        // Esto es √∫til para que el vendedor copie este ID y te lo pase para registrarlo
        const publicMsg = `
üëã <b>Bienvenido a Habana Express</b>

ü§ñ <b>IDENTIFICACI√ìN:</b>
Para vincular tu cuenta, env√≠a este c√≥digo al administrador:

üÜî <code>${chatId}</code>

<i>Esperando autorizaci√≥n...</i>
        `;
        return ctx.reply(publicMsg, { parse_mode: 'HTML' });
    });

    bot.help((ctx) => ctx.reply("Contacte al administrador para soporte.", { parse_mode: 'HTML' }));

    // üîí MIDDLEWARE DE SEGURIDAD PARA REPORTES
    // Funci√≥n auxiliar para verificar si es admin antes de ejecutar
    const verifyAdmin = async (ctx, next) => {
        const chatId = ctx.chat.id.toString();
        const user = await prisma.users.findFirst({ where: { telegram_chat_id: chatId } });

        if (user && user.role === 'admin') {
            return next();
        } else {
            return ctx.reply("‚õî <b>Acceso Denegado:</b> Comando solo para Administradores.", { parse_mode: 'HTML' });
        }
    };

    // 1. REPORTE MENSUAL (Protegido)
    bot.command('monthly', async (ctx) => {
        verifyAdmin(ctx, async () => {
            try {
                ctx.reply("‚è≥ <i>Calculando cierre mensual...</i>", { parse_mode: 'HTML' });
                const data = await getMonthlyReport();
                const roi = data.investment > 0 ? ((data.netProfit / data.investment) * 100).toFixed(1) : "0.0";
                
                const msg = `
üìä <b>CIERRE MENSUAL</b> | ${data.month}/${data.year}
üè¢ <b>Habana Express Store</b>
${separator}
üí∞ <b>INGRESOS (Ventas):</b>
${formatCurrency(data.income)}

üìâ <b>EGRESOS (Costo + Env√≠os):</b>
${formatCurrency(data.investment + data.returnLosses)}

üíé <b>GANANCIA NETA:</b>
${formatCurrency(data.netProfit)}

üìà <b>ROI DEL MES:</b> <code>${roi}%</code>
                `;
                ctx.reply(msg, { parse_mode: 'HTML' });
            } catch (e) {
                console.error("Monthly Error:", e);
                ctx.reply("‚ùå Error generando reporte.");
            }
        });
    });

    // 2. REPORTE ANUAL (Protegido)
    bot.command('yearly', async (ctx) => {
        verifyAdmin(ctx, async () => {
            try {
                ctx.reply("‚è≥ <i>Calculando cierre anual...</i>", { parse_mode: 'HTML' });
                const data = await getAnnualReport();
                const roi = data.investment > 0 ? ((data.netProfit / data.investment) * 100).toFixed(1) : "0.0";

                const msg = `
üìà <b>CIERRE ANUAL</b> | ${data.year}
üè¢ <b>Resumen Global</b>
${separator}
üí∞ <b>INGRESOS ACUMULADOS:</b>
${formatCurrency(data.income)}

üìâ <b>INVERSI√ìN TOTAL:</b>
${formatCurrency(data.investment + data.returnLosses)}

üèÜ <b>GANANCIA NETA TOTAL:</b>
${formatCurrency(data.netProfit)}

üìä <b>ROI PROMEDIO:</b> <code>${roi}%</code>
                `;
                ctx.reply(msg, { parse_mode: 'HTML' });
            } catch (e) {
                console.error("Yearly Error:", e);
                ctx.reply("‚ùå Error generando reporte.");
            }
        });
    });
};

// --- üöÄ INITIALIZATION ---
export const initTelegramBot = async () => {
  try {
    const config = await prisma.system_configuration.findFirst();

    if (!config || !config.telegram_bot_token) {
      console.warn("‚ö†Ô∏è Telegram Bot Token not configured.");
      return;
    }

    bot = new Telegraf(config.telegram_bot_token, {
      telegram: { apiRoot: "https://api.telegram.org" },
      handlerTimeout: 30000
    });

    bot.catch((err) => console.error("‚ùå Telegram Runtime Error:", err));

    setupCommands();

    bot.launch({
      dropPendingUpdates: true,
      polling: { timeout: 30, limit: 100 }
    });

    console.log("ü§ñ Telegram bot running üöÄ");

    process.once('SIGINT', () => bot.stop('SIGINT'));
    process.once('SIGTERM', () => bot.stop('SIGTERM'));

  } catch (error) {
    console.error("‚ùå Critical Error initializing Bot:", error.message);
  }
};


// --- üîî NOTIFICACIONES DEL SISTEMA ---

// 1. NUEVA VENTA (Con Diezmo)
export const notifySale = async (sale) => {
  if (!bot) return;

  try {
      const config = await prisma.system_configuration.findFirst();
      const commissionPct = config ? Number(config.seller_commission_percentage) : 0;

      // C√°lculos B√°sicos
      const exchangeRate = Number(sale.exchange_rate);
      const totalCUP = Number(sale.total_cup);
      const totalUSD = exchangeRate > 0 ? totalCUP / exchangeRate : 0;

      let itemsList = "";
      let totalProductCostUSD = 0;
      const warrantyItems = []; 

      sale.sale_products.forEach(item => {
          const product = item.product;
          itemsList += `‚ñ´Ô∏è <b>${item.quantity}x</b> ${product.name}\n`;
          totalProductCostUSD += (Number(product.purchase_price) * item.quantity);

          if (product.warranty === true) {
              warrantyItems.push({
                  name: product.name,
                  sku: product.sku || 'S/N',
                  quantity: item.quantity
              });
          }
      });

      // 1. C√°lculos de Ganancia
      const commissionUSD = totalUSD * (commissionPct / 100);
      const netProfitUSD = totalUSD - totalProductCostUSD - commissionUSD;

      // üî¥ CORRECCI√ìN AQU√ç: Calculamos ROI (Ganancia / Costo) en vez de Margen (Ganancia / Venta)
      const roiPercentage = totalProductCostUSD > 0 
          ? (netProfitUSD / totalProductCostUSD) * 100 
          : 0;

      // Valores para el Vendedor
      const commissionCUP = commissionUSD * exchangeRate;
      const cashToDeliverCUP = totalCUP - commissionCUP;

      // ‚õ™ C√ÅLCULO DEL DIEZMO (10% de la Ganancia Neta)
      const titheUSD = Math.max(0, netProfitUSD * 0.10);
      const titheCUP = titheUSD * exchangeRate;

      // üÖ∞Ô∏è MENSAJE ADMIN (Financiero Actualizado)
      const adminMsg = `
üí∏ <b>NUEVA VENTA CONFIRMADA</b>
üÜî <b>Ticket:</b> <code>#SALE-${sale.id_sale}</code>
${separator}
üë§ <b>Vendedor:</b> ${sale.seller.name}
üì± <b>Cliente:</b> <code>${sale.buyer_phone}</code>

üõí <b>CARRITO:</b>
${itemsList}${separator}
üíµ <b>BALANCE FINANCIERO:</b>
üü¢ <b>Ingreso Total:</b> ${formatCurrency(totalUSD)}
üî¥ <b>Costo Merc.:</b> ${formatCurrency(totalProductCostUSD)}
ü§ù <b>Comisi√≥n:</b>     ${formatCurrency(commissionUSD)}

üöÄ <b>GANANCIA NETA:</b> ${formatCurrency(netProfitUSD)}
üìà <b>Rentabilidad:</b>  <code>${roiPercentage.toFixed(1)}%</code>
‚õ™ <b>DIEZMO (10%):</b>  ${formatCurrency(titheCUP, 'CUP')}
üí± <b>Tasa Aplicada:</b> <code>${exchangeRate}</code>
      `;

      const admins = await prisma.users.findMany({ where: { role: 'admin', telegram_chat_id: { not: null } } });
      for (const admin of admins) {
          await safeReply(admin.telegram_chat_id, adminMsg);
      }

      // üÖ±Ô∏è MENSAJE VENDEDOR (Motivacional - Igual que antes)
      const sellerMsg = `
üí∏ <b>¬°EXCELENTE VENTA, ${sale.seller.name.toUpperCase()}!</b>
üìÖ ${formatDateTime(sale.sale_date)}
${separator}
üì¶ <b>Has vendido:</b>
${itemsList}${separator}
üíº <b>CAJA (A Entregar):</b>
${formatCurrency(cashToDeliverCUP, 'CUP')}

üí∞ <b>TU COMISI√ìN:</b>
${formatCurrency(commissionCUP, 'CUP')} üéâ

üöÄ <i>¬°Sigue as√≠!</i>
      `;

      if (sale.seller && sale.seller.telegram_chat_id) {
          await safeReply(sale.seller.telegram_chat_id, sellerMsg);
      }

      // üÖæÔ∏è GARANT√çA (Igual que antes)
      if (warrantyItems.length > 0) {
          const saleDate = new Date(sale.sale_date);
          const expirationDate = addDays(saleDate, 7);
          let warrantyList = "";
          warrantyItems.forEach(p => {
              warrantyList += `üì¶ <b>${p.name}</b>\nüî¢ SKU: <code>${p.sku}</code>\n`;
          });
          const warrantyMsg = `
üìÉ <b>CERTIFICADO DE GARANT√çA</b>
üÜî <b>Ticket:</b> <code>#SALE-${sale.id_sale}</code>
${separator}
üìÖ <b>Emisi√≥n:</b> ${formatDate(saleDate)}
‚ö†Ô∏è <b>VENCE:</b> ${formatDate(expirationDate)} (7 D√≠as)
üì± <b>Cliente:</b> <code>${sale.buyer_phone}</code>
${separator}
<b>PRODUCTOS CUBIERTOS:</b>
${warrantyList}
${separator}
‚ÑπÔ∏è <i>Cubre defectos de f√°brica. No humedad ni golpes.</i>
          `;
          for (const admin of admins) { await safeReply(admin.telegram_chat_id, warrantyMsg); }
          if (sale.seller && sale.seller.telegram_chat_id) { await safeReply(sale.seller.telegram_chat_id, warrantyMsg); }
      }

  } catch (error) { 
      console.error("Notify Sale Error:", error.message); 
  }
};
// 2. GARANT√çA VENCIDA
export const notifyWarrantyExpiration = async (sale, products) => {
    if (!bot) return;

    try {
        let productList = "";
        products.forEach(p => {
             productList += `üì¶ ${p.name}\n   SKU: <code>${p.sku}</code>\n`;
        });

        // Mensaje para Admin
        const msgAdmin = `
üïí <b>GARANT√çA VENCIDA</b> (7 D√≠as)
üÜî <b>Ticket:</b> <code>#SALE-${sale.id_sale}</code>
${separator}
üì± <b>Cliente:</b> <code>${sale.buyer_phone}</code>
üìÖ <b>Venta:</b> ${formatDate(sale.sale_date)}

<b>PRODUCTOS SIN COBERTURA:</b>
${productList}
‚úÖ <b>Estado:</b> Caso Cerrado.
        `;

        // Mensaje para Vendedor
        const msgSeller = `
üïí <b>AVISO: GARANT√çA EXPIRADA</b>
El cliente <code>${sale.buyer_phone}</code> ya no tiene cobertura.
${separator}
<b>PRODUCTOS:</b>
${productList}
üö´ <i>No aceptar devoluciones de este ticket.</i>
        `;

        const admins = await prisma.users.findMany({ where: { role: 'admin', telegram_chat_id: { not: null } } });
        admins.forEach(u => safeReply(u.telegram_chat_id, msgAdmin));

        if (sale.seller && sale.seller.telegram_chat_id) {
            await safeReply(sale.seller.telegram_chat_id, msgSeller);
        }

    } catch (e) { console.error("Warranty Exp Error:", e); }
};

// 3. STOCK AGOTADO (Con An√°lisis de Lote)
export const notifyStockDepletion = async (product) => {
  if (!bot) return;
  try {
    const config = await prisma.system_configuration.findFirst();
    const commissionPct = config ? Number(config.seller_commission_percentage) : 0;

    // Buscar historial de ventas para calcular rentabilidad real del lote
    const salesHistory = await prisma.sale_products.findMany({
        where: { id_product: product.id_product },
        include: { sale: true } // Necesario para saber tasa hist√≥rica si quisieras afinar
    });

    let totalQuantitySold = 0;
    salesHistory.forEach(item => { totalQuantitySold += item.quantity; });

    const purchasePrice = Number(product.purchase_price);
    const totalInvestmentUSD = purchasePrice * totalQuantitySold;
    
    // Estimaci√≥n x2 (Precio venta est√°ndar)
    const totalRevenueUSD = totalInvestmentUSD * 2; 
    const totalCommissionsUSD = totalRevenueUSD * (commissionPct / 100);
    const netProfitUSD = totalRevenueUSD - totalInvestmentUSD - totalCommissionsUSD;

    const msg = `
‚ö° <b>STOCK AGOTADO</b>
üì¶ <b>Producto:</b> ${product.name}
${separator}
üèÅ <b>RESUMEN DEL LOTE:</b>
üî¢ <b>Unidades Vendidas:</b> <code>${totalQuantitySold}</code>
üìâ <b>Inversi√≥n Total:</b> ${formatCurrency(totalInvestmentUSD)}

üèÜ <b>GANANCIA ESTIMADA:</b>
${formatCurrency(netProfitUSD)}

‚ö†Ô∏è <i>Producto desactivado del cat√°logo autom√°ticamente.</i>
    `;

    const admins = await prisma.users.findMany({ where: { role: 'admin', telegram_chat_id: { not: null } } });
    admins.forEach(u => safeReply(u.telegram_chat_id, msg));

  } catch (error) { console.error("Notify Stock Error:", error.message); }
};

// 4. SINCRONIZACI√ìN DIARIA (ADMIN)
export const notifyDailyUpdate = async (newRate, productsCount) => {
    if (!bot) return;
    try {
        const msg = `
üåê <b>SINCRONIZACI√ìN DIARIA</b>
üìÖ ${formatDateTime(new Date())}
${separator}
üá∫üá∏ <b>TASA DE CAMBIO:</b>
<code>1 USD = ${newRate} CUP</code>

üè∑Ô∏è <b>CAT√ÅLOGO ACTUALIZADO:</b>
‚úÖ <b>${productsCount}</b> Productos recalcularon su precio en CUP.
        `;
        const admins = await prisma.users.findMany({ where: { role: 'admin', telegram_chat_id: { not: null } } });
        admins.forEach(u => safeReply(u.telegram_chat_id, msg));
    } catch (e) { console.error(e); }
};

// 5. LISTA DE PRECIOS DIARIA (VENDEDOR)
export const notifyDailyPrices = async (seller, newRate) => {
    if (!bot || !seller.telegram_chat_id) return;
    try {
        let msg = `
üëã <b> Hola </b> <b> ${seller.name} </b>
üí≤ <b>LISTA DE PRECIOS DE HOY:</b>
üóìÔ∏è <b>Fecha:</b> ${formatDate(new Date())}
üíµ <b>Tasa Base:</b> <code>${newRate} CUP</code>
${separator}
<pre>
PRODUCTO         | STOCK | PRECIO CUP
-----------------|-------|-----------
`;
        seller.seller_products.forEach(sp => {
            const priceNow = Number(sp.product.purchase_price) * 2 * newRate;
            // Truncar nombre a 16 chars
            const shortName = sp.product.name.substring(0, 16).padEnd(16, ' ');
            const stock = sp.quantity.toString().padStart(5, ' ');
            // Formatear precio sin decimales y con comas
            const priceStr = new Intl.NumberFormat('en-US').format(priceNow);
            const price = priceStr.padStart(10, ' ');
            
            msg += `${shortName} | ${stock} | ${price}\n`;
        });
        msg += `</pre>
${separator}
üí° <i>Precios v√°lidos hasta la pr√≥xima actualizaci√≥n.</i>`;
        
        safeReply(seller.telegram_chat_id, msg);
    } catch (e) { console.error(e); }
};

// 6. DEVOLUCI√ìN (COMPLETA Y DETALLADA)
export const notifyReturn = async (returnData, returnToStock) => {
    if (!bot) return;
    try {
        const saleDate = formatDate(returnData.sale.sale_date);
        const sellerName = returnData.sale.seller ? returnData.sale.seller.name : "Desconocido";
        const sku = returnData.product.sku || "Sin SKU";
        
       
        const destinationText = returnToStock 
            ? "‚úÖ <b>Regresa al Stock</b> (Disponible)" 
            : "üóëÔ∏è <b>Desechado / Merma</b> (P√©rdida Total)";

        const msg = `
üîô <b>REPORTE DE DEVOLUCI√ìN</b>
üé´ <b>Ticket:</b> <code>#SALE-${returnData.sale.id_sale}</code>
${separator}
üìÖ <b>Venta Original:</b> ${saleDate}
üë§ <b>Vendedor: </b> ${sellerName}
üì± <b>Cliente: </b> <code>${returnData.sale.buyer_phone}</code>

üì¶ <b>PRODUCTO DEVUELTO:</b>
<b>${returnData.quantity}x</b> ${returnData.product.name}
üî¢ <b>SKU:</b> <code>${sku}</code>

üìù <b>MOTIVO:</b>
<i>"${returnData.reason || 'No especificado'}"</i>
${separator}
üìâ <b>IMPACTO Y DESTINO:</b>
üí∏ <b>P√©rdida:</b> -${formatCurrency(returnData.loss_usd)}
${destinationText}
        `;

        // Notificar solo a Admins
        const recipients = await prisma.users.findMany({
          where: { role: 'admin', telegram_chat_id: { not: null } }
        });

        for (const u of recipients) {
            await safeReply(u.telegram_chat_id, msg);
        }

    } catch (e) { console.error("Notify Return Error:", e); }
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\services\exchangeRate.js
============================================
import axios from "axios";

const API_URL = "https://www.cambiocup.com/api";

export const getDailyExchangeRate = async () => {
  try {
    console.log("üîÑ Fetching Exchange Rate from API...");

    const { data } = await axios.get(API_URL, {
      headers: {
        "User-Agent": "Mozilla/5.0",
        "Accept": "application/json"
      },
      timeout: 8000
    });

    // Validamos que exista la estructura esperada
    const latest = data.cupHistory?.[0]?.value;

    if (!latest) {
      throw new Error("API did not return valid data in cupHistory[0].value");
    }

    // Regla de Negocio: Redondeo a la decena m√°s cercana
    // Ejemplo: 514 -> 510, 515 -> 520
    const finalRate = Math.round(latest / 10) * 10;

    console.log(`‚úÖ Current Rate: ${latest} | Rounded Rate: ${finalRate}`);

    return finalRate;

  } catch (error) {
    console.error("‚ùå Error fetching exchange rate:", error.message);
    return null; // Retornamos null para manejar el error en el Cron Job
  }
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\services\finance.js
============================================
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Helper: Redondeo est√°ndar a entero (sin decimales)
// Ej: 10.4 -> 10, 10.5 -> 11
const roundInt = (val) => Math.round(Number(val));

/**
 * L√≥gica central de c√°lculo financiero
 */
const calculateProfitInPeriod = async (startDate, endDate) => {
  // 1. Obtener Configuraci√≥n (para % de comisi√≥n)
  const config = await prisma.system_configuration.findFirst();
  const commissionPct = config ? Number(config.seller_commission_percentage) : 0;

  // 2. Consultas a BD
  const sales = await prisma.sales.findMany({
    where: { sale_date: { gte: startDate, lte: endDate } },
  });

  const shipments = await prisma.shipments.findMany({
    where: { shipment_date: { gte: startDate, lte: endDate } },
  });

  const returns = await prisma.returns.findMany({
    where: { return_date: { gte: startDate, lte: endDate } },
  });

  // 3. --- INGRESOS (INCOME) ---
  let totalIncomeUSD = 0;
  sales.forEach(sale => {
    const rate = Number(sale.exchange_rate);
    const cup = Number(sale.total_cup);
    if (rate > 0) totalIncomeUSD += cup / rate;
  });

  // 4. --- COSTOS DE INVERSI√ìN (INVESTMENT) ---
  let totalInvestmentUSD = 0;
  shipments.forEach(ship => {
    const shipping = Number(ship.shipping_cost_usd);
    const merch = Number(ship.merchandise_cost_usd);
    const customsCup = Number(ship.customs_fee_cup);
    const rate = Number(ship.exchange_rate);
    const customsUsd = rate > 0 ? customsCup / rate : 0;

    totalInvestmentUSD += (shipping + merch + customsUsd);
  });

  // 5. --- P√âRDIDAS OPERATIVAS (RETURNS) ---
  let returnLossesUSD = 0;
  returns.forEach(ret => {
    returnLossesUSD += Number(ret.loss_usd);
  });

  // 6. --- COMISIONES VENDEDORES ---
  const totalCommissionsUSD = totalIncomeUSD * (commissionPct / 100);

  // 7. --- GANANCIA NETA (Sin Diezmo) ---
  const netProfit = totalIncomeUSD - (totalInvestmentUSD + returnLossesUSD + totalCommissionsUSD);

  // üî• RETORNAMOS VALORES REDONDEADOS A ENTEROS
  return {
    income: roundInt(totalIncomeUSD),
    investment: roundInt(totalInvestmentUSD),
    returnLosses: roundInt(returnLossesUSD),
    commissions: roundInt(totalCommissionsUSD),
    netProfit: roundInt(netProfit)
  };
};

/**
 * Reporte Mensual
 */
export const getMonthlyReport = async () => {
  const now = new Date();
  const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  
  const data = await calculateProfitInPeriod(startOfMonth, now);
  
  return {
    period: "Mensual",
    month: now.getMonth() + 1,
    year: now.getFullYear(),
    ...data
  };
};

/**
 * Reporte Anual
 */
export const getAnnualReport = async () => {
  const now = new Date();
  const startOfYear = new Date(now.getFullYear(), 0, 1);
  
  // 1. Totales Globales (Redondeados)
  const globalData = await calculateProfitInPeriod(startOfYear, now);

  // 2. Desglose para Gr√°ficos
  const breakdown = [];
  for (let i = 0; i < 12; i++) {
    const start = new Date(now.getFullYear(), i, 1);
    const end = new Date(now.getFullYear(), i + 1, 0, 23, 59, 59);
    if (start > now) break;

    const monthData = await calculateProfitInPeriod(start, end);
    
    // ROI se deja con 2 decimales porque es un porcentaje (ej: 12.5%)
    let roi = 0;
    if (monthData.investment > 0) {
      roi = (monthData.netProfit / monthData.investment) * 100;
    }

    breakdown.push({
      month: i + 1,
      investment: monthData.investment, // Ya viene redondeado
      profit: monthData.netProfit,      // Ya viene redondeado
      roiPercentage: parseFloat(roi.toFixed(2)) // Mantenemos decimales solo en ROI
    });
  }

  return {
    period: "Anual",
    year: now.getFullYear(),
    ...globalData, 
    breakdown: breakdown,
    totalNetProfit: globalData.netProfit
  };
};

/**
 * Ranking de Mejores Vendedores
 */
export const calculateTopSellers = async (period) => {
  const now = new Date();
  let startDate;

  if (period === 'month') {
    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
  } else {
    startDate = new Date(now.getFullYear(), 0, 1);
  }

  const sales = await prisma.sales.findMany({
    where: { sale_date: { gte: startDate } },
    include: { seller: true, sale_products: true }
  });

  const sellerStats = {};

  sales.forEach(sale => {
    const sellerId = sale.id_seller;
    const rate = Number(sale.exchange_rate);
    const cup = Number(sale.total_cup);
    const usdAmount = rate > 0 ? cup / rate : 0;
    
    const itemsCount = sale.sale_products.reduce((acc, item) => acc + item.quantity, 0);

    if (!sellerStats[sellerId]) {
      sellerStats[sellerId] = {
        id_user: sellerId,
        name: sale.seller.name,
        photo_url: sale.seller.photo_url,
        total_sales_usd: 0,
        items_sold: 0
      };
    }

    sellerStats[sellerId].total_sales_usd += usdAmount;
    sellerStats[sellerId].items_sold += itemsCount;
  });

  const ranking = Object.values(sellerStats)
    .sort((a, b) => b.total_sales_usd - a.total_sales_usd)
    .map(seller => ({
        ...seller,
        // üî• Redondeamos el total vendido aqu√≠
        total_sales_usd: roundInt(seller.total_sales_usd)
    }));

  return ranking;
};.
.
============================================
Archivo: C:\Users\gabry\Desktop\Habana Express Store\habana-express-api\src\services\scheduler.js
============================================
import cron from 'node-cron';
import { PrismaClient } from '@prisma/client';
import { getDailyExchangeRate } from './exchangeRate.js';
import { 
    notifyDailyUpdate, 
    notifyDailyPrices, 
    notifyWarrantyExpiration 
} from '../telegram.js';

const prisma = new PrismaClient();

export const executeDailyUpdate = async () => {
  console.log("‚è∞ Starting Daily Price Update Routine...");

  try {
    const newRate = await getDailyExchangeRate();
    if (!newRate) return;

    const config = await prisma.system_configuration.findFirst();
    if (config) {
      await prisma.system_configuration.update({
        where: { id_config: config.id_config },
        data: { default_exchange_rate: newRate }
      });
    }

    const products = await prisma.products.findMany({ where: { active: true } });
    
    if (products.length > 0) {
        const updatePromises = products.map(product => {
            const cost = Number(product.purchase_price);
            const newSalePrice = cost * 2 * newRate;
            return prisma.products.update({
                where: { id_product: product.id_product },
                data: { sale_price: newSalePrice }
            });
        });

        await prisma.$transaction(updatePromises);
        console.log(`‚úÖ Prices updated for ${products.length} products.`);

        await notifyDailyUpdate(newRate, products.length);

        const sellers = await prisma.users.findMany({
            where: { role: 'seller', active: true, telegram_chat_id: { not: null } },
            include: { seller_products: { include: { product: true } } }
        });

        for (const seller of sellers) {
            if (seller.seller_products.length > 0) {
                await notifyDailyPrices(seller, newRate);
            }
        }
    }

  } catch (error) {
    console.error("‚ùå CRITICAL ERROR during daily update:", error);
  }
};

/**
 * Tarea 2: Chequeo de Garant√≠as Vencidas
 */
export const checkExpiredWarranties = async () => {
    console.log("üõ°Ô∏è Checking expired warranties...");
    try {
        const today = new Date();
        const sevenDaysAgo = new Date(today);
        sevenDaysAgo.setDate(today.getDate() - 7);

        const startOfDay = new Date(sevenDaysAgo.setHours(0, 0, 0, 0));
        const endOfDay = new Date(sevenDaysAgo.setHours(23, 59, 59, 999));

        const sales = await prisma.sales.findMany({
            where: {
                sale_date: {
                    gte: startOfDay,
                    lte: endOfDay
                }
            },
            include: {
                // üî• IMPORTANTE: Incluir Vendedor para notificarle
                seller: true,
                sale_products: {
                    include: { product: true }
                }
            }
        });

        for (const sale of sales) {
            const warrantyProducts = sale.sale_products
                .map(sp => sp.product)
                .filter(p => p.warranty === true);

            if (warrantyProducts.length > 0) {
                // Notificar a Admin y Vendedor
                await notifyWarrantyExpiration(sale, warrantyProducts);
                console.log(`‚úÖ Warranty expired notification sent for Sale #${sale.id_sale}`);
            }
        }

    } catch (error) {
        console.error("‚ùå Error checking warranties:", error);
    }
};

export const initScheduler = () => {
  console.log("üìÖ Initializing Schedulers...");

  // 1. Chequeo de Tasa (Minuto a minuto)
  cron.schedule('* * * * *', async () => {
    try {
        const config = await prisma.system_configuration.findFirst();
        if (!config || !config.exchange_rate_sync_time) return;

        const now = new Date();
        const cubaTime = new Date(now.toLocaleString("en-US", { timeZone: "America/Havana" }));
        
        const targetTime = new Date(config.exchange_rate_sync_time);

        if (cubaTime.getHours() === targetTime.getUTCHours() && 
            cubaTime.getMinutes() === targetTime.getUTCMinutes()) {
             console.log(`‚ö° Executing Daily Price Update...`);
             await executeDailyUpdate();
        }

    } catch (error) {
        console.error("Scheduler Error:", error.message);
    }
  });

  // 2. Chequeo de Garant√≠as (Diario a las 9 AM)
  cron.schedule('0 9 * * *', async () => {
      await checkExpiredWarranties();
  });

  console.log("‚úÖ Scheduler services are running.");
};.
.
